#  Last Modified Date: 04/30/2024
#' @name AnalyzeUsingModestlyWeightedLogRank
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'          SimData$ArrivalTime A numeric value with the time the patient arrived in the trial
#'          SimData$TreatmentID An integer value where 0 indicates control treatment and 1 experimental treatment.
#'          SimData$SurvivalTime Numeric value for the survival time or time-to-event for the patient, note this is not the time in the trial
#'                               that the patient experiences the event. 
#' @param DesignParam Input Parameters which user may need to compute test statistic and perform test. 
#'                    User should access the variables using names, for example,  DesignParam$Alpha, and not order. 
#'                    For details of this list please see below. 
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                   LookInfo$NumLooks An integer value with the number of looks in the study
#'                   LookInfo$CurrLookIndex An integer value with the current index look, starting from 1
#'                   LookInfo$CumEvents A vector of length LookInfo$NumLooks that contains the number of events at the look.
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Required value. Integer Value with the following meaning:
#'                                  \describe{
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is  crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    \item{Decision = 4}{when the Equivalence Boundary Crossed}
#'                                    } 
#'                                    }
#'                  \item{ErrorCode}{Optional integer value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                  \item{HazardRatio}{Optional numeric value. 
#'                                            Used in Solara for creating the observed hazard ratio graph. 
#'                                            Only applicable for time-to-event data.}
#'                      }
AnalyzeUsingModestlyWeightedLogRankWithgsDesignBounds <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    nError <- 0 
    # Example of saving parameters (EAST ONLY)
    # setwd( "C:\\Kyle\\Cytel\\Software\\CyneRgyExamples\\AnalyzeUsingModestlyWeightedLogRank\\ExampleArgumentsFromEast\\Example1")
    # #setwd( "[ENTERED THE DESIRED LOCATION TO SAVE THE FILE]" )
    # saveRDS( SimData, "SimData.Rds")
    # saveRDS( DesignParam, "DesignParam.Rds" )
    # saveRDS( LookInfo, "LookInfo.Rds" )
    # saveRDS( UserParam, "UserParam.Rds" )
    
    nLookIndex           <- 1 
    
    if( !is.null( LookInfo ) )
    {
        # Look info was provided so use it
        nLookIndex   <- LookInfo$CurrLookIndex
        nQtyOfEvents <- LookInfo$CumEvents[ nLookIndex ]
    }
    else
    {
        nQtyOfEvents         <- DesignParam$MaxEvents 
    }
    

    SimData$TimeOfEvent  <- SimData$ArrivalTime + SimData$SurvivalTime    # This is the calendar time in the trial that the patients event is observed
    
    # Timing of analysis - Comment out one of the options####
    # Option 1 - Compute the time of analysis based on observed number of events
    #SimData              <- SimData[ order( SimData$TimeOfEvent), ]
    #dTimeOfAnalysis      <- SimData[ nQtyOfEvents, ]$TimeOfEvent
    
    # Option 2 - Set the time
    dTimeOfAnalysis <- gvTimeOfAnalysis[ nLookIndex ]
    
    # Add the Observed Time variable 
    SimData              <- SimData[ SimData$ArrivalTime <= dTimeOfAnalysis ,]   # Exclude any patients that were not enrolled by the time of the analysis
    SimData$Event        <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, 0, 1 )  # If the event is observed after the analysis it is not observed, eg censored 
    SimData$ObservedTime <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, dTimeOfAnalysis - SimData$ArrivalTime, SimData$TimeOfEvent - SimData$ArrivalTime )
    
    # Analysis - Use gsdelayed::wlrt to analyze the data ####
    fitWeightedLogRank <- wlrt( SimData, 
                                           trt_colname   = "TreatmentID", 
                                           time_colname  = "ObservedTime", 
                                           event_colname = "Event", 
                                           wlr           = "mw", 
                                           t_star        = UserParam$tStar )

    if( nLookIndex < LookInfo$NumLooks )  # Interim analysis 
    {
        nDecision <- ifelse(  -1*fitWeightedLogRank$z  >= gvBounds[ nLookIndex ], 2, 0 )  # If 
    }
    else
    {
        # Final analysis 
        nDecision <- ifelse(  -1*fitWeightedLogRank$z  >= gvBounds[ nLookIndex ], 2, 3 )
    }
    

    lRet <- list(TestStat = as.double(fitWeightedLogRank$z),
                 Decision  = as.integer(nDecision), 
                 ErrorCode = as.integer(nError))
    return( lRet )
}

