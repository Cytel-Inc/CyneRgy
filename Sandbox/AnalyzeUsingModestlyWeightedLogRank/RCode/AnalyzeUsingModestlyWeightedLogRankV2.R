#  Last Modified Date: 04/30/2024
#' @name AnalyzeUsingModestlyWeightedLogRank
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'          SimData$ArrivalTime A numeric value with the time the patient arrived in the trial
#'          SimData$TreatmentID An integer value where 0 indicates control treatment and 1 experimental treatment.
#'          SimData$SurvivalTime Numeric value for the survival time or time-to-event for the patient, note this is not the time in the trial
#'                               that the patient experiences the event. 
#' @param DesignParam Input Parameters which user may need to compute test statistic and perform test. 
#'                    User should access the variables using names, for example,  DesignParam$Alpha, and not order. 
#'                    For details of this list please see below. 
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                   LookInfo$NumLooks An integer value with the number of looks in the study
#'                   LookInfo$CurrLookIndex An integer value with the current index look, starting from 1
#'                   LookInfo$CumEvents A vector of length LookInfo$NumLooks that contains the number of events at the look.
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Required value. Integer Value with the following meaning:
#'                                  \describe{
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is  crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    \item{Decision = 4}{when the Equivalence Boundary Crossed}
#'                                    } 
#'                                    }
#'                  \item{ErrorCode}{Optional integer value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                  \item{HazardRatio}{Optional numeric value. 
#'                                            Used in Solara for creating the observed hazard ratio graph. 
#'                                            Only applicable for time-to-event data.}
#'                      }
AnalyzeUsingModestlyWeightedLogRankWithgsDesignBounds <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    nError <- 0 

    nLookIndex           <- 1 
    
    if( !is.null( LookInfo ) )
    {
        # Look info was provided so use it, this is a group sequential design
        nLookIndex       <- LookInfo$CurrLookIndex
        nQtyOfEvents     <- LookInfo$CumEvents[ nLookIndex ]
        
        vTimeOfAnalysis  <- c()
        vBounds          <- c()
        for( nAnalysisIndex in 1:LookInfo$NumLooks )
        {
            vTimeOfAnalysis <- c( vTimeOfAnalysis, UserParam[[ paste0( "nAnalysisTime", nAnalysisIndex) ]] )
            vBounds          <- c( vBounds, UserParam[[ paste0( "dBound", nAnalysisIndex) ]] )
        }
    }
    else
    {
        # Fixed Design
        
        nQtyOfEvents    <- DesignParam$MaxEvents 
        vBounds         <- c( UserParam$dBound1 )
        vTimeOfAnalysis <- c( UserParam$nAnalysisTime1 )
    }
    

    SimData$TimeOfEvent  <- SimData$ArrivalTime + SimData$SurvivalTime    # This is the calendar time in the trial that the patients event is observed
    
    # Timing of analysis - Comment out one of the options####
    # Option 1 - Compute the time of analysis based on observed number of events, number of events are specified in the Solara card
    #SimData              <- SimData[ order( SimData$TimeOfEvent), ]
    #dTimeOfAnalysis      <- SimData[ nQtyOfEvents, ]$TimeOfEvent
    
    # Option 2 - Set the time
    dTimeOfAnalysis <- vTimeOfAnalysis[ nLookIndex ]
    
    # Add the Observed Time variable 
    SimData              <- SimData[ SimData$ArrivalTime <= dTimeOfAnalysis ,]   # Exclude any patients that were not enrolled by the time of the analysis
    SimData$Event        <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, 0, 1 )  # If the event is observed after the analysis it is not observed, eg censored 
    SimData$ObservedTime <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, dTimeOfAnalysis - SimData$ArrivalTime, SimData$TimeOfEvent - SimData$ArrivalTime )
    
    # Analysis - Use gsdelayed::wlrt to analyze the data ####
    fitWeightedLogRank <- wlrt( SimData, 
                                           trt_colname   = "TreatmentID", 
                                           time_colname  = "ObservedTime", 
                                           event_colname = "Event", 
                                           wlr           = "mw", 
                                           t_star        = UserParam$tStar )


    
    if( nLookIndex < LookInfo$NumLooks )  # Interim analysis 
    {
        nDecision <- ifelse(  -1*fitWeightedLogRank$z  >= vBounds[ nLookIndex ], 2, 0 )  # If 
    }
    else
    {
        # Final analysis 
        nDecision <- ifelse(  -1*fitWeightedLogRank$z  >= vBounds[ nLookIndex ], 2, 3 )
    }
    
    # TODO - How should we estimate the HR, this can be displayed in Solara's graphs
    dTrueHR <- 1 + runif(1, -0.4,0 )  # Just adding something between 0.6, 1 so we can get the graph
    
    
    lRet <- list(TestStat = as.double(fitWeightedLogRank$z),
                 HazardRatio = as.double( dTrueHR ),
                 Decision  = as.integer(nDecision), 
                 ErrorCode = as.integer(nError))
    return( lRet )
}


 

#' Weighted log-rank test from the gsdelayed package by Dominic Magirr (https://github.com/dominicmagirr/gsdelayed)
#'
#' @param df A data frame. Assume standard structure for time-to-event data.
#' @param trt_colname A character string. The name of the treatment column in \code{df}.
#' @param time_colname A character string. The name of the column in \code{df} with the survival times.
#' @param event_colname A character string. The name of the column in \code{df} with the event status. Assumes 1 means event; 0 means censored.
#' @param wlr The type of weighted log-rank test. Either the default "lr" for a standard log-rank test, "mw" for a modestly-weighted log-rank test, or "fh" for the Fleming-Harrington rho-gamma family.
#' @param s_star This is a parameter for the "mw"-test. Either \code{s_star} or \code{t_star} must be specified. The weights are defined as w(t) = 1 / max(S(t-), \code{s_star}), where S is the Kaplan-Meier estimate in the pooled data.
#' @param t_star This is a parameter for the "mw"-test. Either \code{s_star} or \code{t_star} must be specified. The weights are defined as w(t) = 1 / max(S(t-), S(\code{t_star}), where S is the Kaplan-Meier estimate in the pooled data.
#' @param rho Rho parameter in the "fh"-test. The weights are defined as w(t) = S(t-)^\code{rho} (1 - S(t-))^\code{gamma}, where S is the Kaplan-Meier estimate in the pooled data.
#' @param gamma Gamma parameter in the "fh"-test. The weights are defined as w(t) = S(t-)^\code{rho} (1 - S(t-))^\code{gamma}, where S is the Kaplan-Meier estimate in the pooled data.
#' @return A data frame. The outcome of the weighted log-rank test. There is a column \code{o_minus_e_trt} to indicate which treatment the "obs - exp" refers to.
#' @export

wlrt <- function(df,
                 trt_colname,
                 time_colname,
                 event_colname,
                 wlr = "lr",
                 s_star = NULL,
                 t_star = NULL,
                 rho = NULL,
                 gamma = NULL){
    
    if(!all(is.character(c(trt_colname,
                           time_colname,
                           event_colname)))) stop("trt_colname, time_colname and event_colname must all be character strings")
    
    if (any(is.na(df[,c(trt_colname,
                        time_colname,
                        event_colname)]))) stop("NA's in data set. wlrt doesn't have a default for missing data.")
    
    if (!(wlr %in% c("lr", "fh", "mw"))) stop("wlr must be one of: 'lr', 'fh', 'mw'")
    
    #### fit pooled data
    fit_pool <- survival::survfit(survival::Surv(eval(as.name(time_colname)),
                                                 eval(as.name(event_colname))) ~ 1,
                                  data= df,
                                  timefix = FALSE)
    
    
    ### get survival probabilities for the pooled data
    fail <- fit_pool$time[fit_pool$n.event > 0]
    km_pool <- fit_pool$surv[fit_pool$n.event > 0]
    km_pool_minus <- c(1, km_pool[1:(length(km_pool) - 1)])
    
    
    if (wlr == "lr"){
        ### standard log-rank test weights
        w <- rep(1, length(km_pool_minus))
    }
    else if (wlr == "fh"){
        if (is.null(rho) || is.null(gamma)) stop("must specify rho and gamma")
        if (rho < 0 || gamma < 0) stop("rho and gamma must be non-negative")
        
        w <- km_pool_minus ^ rho * (1 - km_pool_minus) ^ gamma
        
    }
    else{
        if (is.null(t_star) && is.null(s_star)) stop("must specify either t_star or s_star")
        if (!is.null(t_star) && !is.null(s_star)) stop("must specify either t_star or s_star (not both)")
        ### modest weights
        if (!is.null(t_star)){
            
            if(any(fail < t_star)){
                
                w <- pmin(1 / km_pool_minus,
                          1 / km_pool[max(which(fail < t_star))])
            }
            else {
                w <- rep(1, length(km_pool_minus))
            }
            
        }
        else {
            w <- pmin(1 / km_pool_minus,
                      1 / s_star)
        }
    }
    
    ### produce risk table
    trt <- df[[trt_colname]]
    u_trt <- sort(unique(trt))
    k <- length(u_trt) ### always equal to 2 in this package
    times <- df[[time_colname]]
    status <- df[[event_colname]]
    
    neventg <- table(trt[status > 0], times[status > 0])
    nevent <- colSums(neventg)
    
    nriskg <- matrix(1, length(fail), k)
    for (i in 1:k) nriskg[, i] <- colSums(matrix(rep(fail,each = sum(trt == u_trt[i])),,length(fail)) <= times[trt == u_trt[i]])
    nrisk <- rowSums(nriskg)
    
    ## test statistics
    
    observed <- w %*% t(neventg)
    expected <- w %*% (nriskg * (nevent/nrisk))
    
    u <- (observed - expected)[, 2]
    
    v_u <- w^2 * (nevent * (nrisk - nevent)/(nrisk - 1))
    v_u[nrisk == 1] <- 0
    v_u <- (diag(c(v_u %*% (nriskg/nrisk))) - t(nriskg/nrisk) %*% ((nriskg/nrisk) * v_u))[2,2]
    
    z = u / sqrt(v_u)
    
    data.frame(u = (observed - expected)[, 2],
               v_u = v_u,
               z = z,
               o_minus_e_trt = names((observed - expected)[, 2]))
    
}

