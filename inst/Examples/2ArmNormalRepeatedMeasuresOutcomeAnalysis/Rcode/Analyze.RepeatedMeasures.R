#' Last Modified Date: 07/17/2024
#' @name Analyze.RepeatedMeasures
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{ArrivalTime}{ A numeric value with the time the patient arrived in the trial}
#'          \item{ArrTimeVisit<VisitID>}{A numeric value with the time the patient arrived in the trial for the <VisitID>th visit.}
#'          \item{TreatmentID}{An integer value where 0 indicates control treatment and 1 experimental treatment.}
#'          \item{Response<VisitID>}{Numeric value for the response from the patient at the <VisitID>th visit. }
#'          \item{CensorInd<VisitID>}{A binary (0-1) value where 1 indicates that the patient was censored at the <VisitID>th visit.}
#'          \item{DropoutVisitID}{An integer value which indicates the ID of the visit where the patient was censored. }
#'        }
#' @param DesignParam R List which consists of Design and Simulation Parameters which user
#'      may need to compute test statistic and perform test. User should access the variables
#'      using names for eg. DesignParam$Alpha and not order.  Them items are as follows:
#'      \describe{
#'          \item{SampleSize}{Sample size of the trial}
#'          \item{Alpha}{Type I Error}
#'          \item{TestType}{Values are One side: 0; Two Sided: 1, Two Sided, Asymmetric: 2 }
#'          \item{TailType}{Values are Left Tailed: 0, Right Tailed: 1}
#'          \item{LowerAlpha}{Two Sided Asymmetric Tests }
#'          \item{UpperAlpha}{Two Sided Asymmetric Tests }
#'          \item{MaxCompleters}{Maximum Completers for a Continuous ep design}
#'          \item{ResponseLag}{Fixed Followup time between first visit and Final visit }
#'          \item{AllocInfo}{Allocation ratio on Control and Experimental arm }
#'          \item{CriticalPoint}{Z Critical value for a given Alpha}
#'          \item{NumVisit}{Integer number of visits in a Design}
#'          \item{VisitTime}{Numeric vector containing visit times}
#'          \item{VisitStatus}{Integer vector indicating the visit selection status. 0 - Visit selected for analysis. 1 - Otherwise }
#'          \item{PrimContrastCoeff}{Numeric vector containing Primary Contrast Coefficient per visit }
#'          \item{SecContrastCoeff}{Numeric vector containing Secondary Contrast Coefficient per visit }
#'          \item{DropImpt}{Integer value for Dropout imputation method. 1 indicates None, 0 indicates LOCF }
#'      }
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                 \describe{
#'                      \item{NumLooks}{An integer value with the number of looks in the study}
#'                      \item{CurrLookIndex}{An integer value with the current index look, starting from 1}
#'                      \item{CumCompleters}{Cumulative number of completer for all non time-to-event studies.}
#'                      \item{InfoFrac}{Information fraction}
#'                      \item{EffBdryScale}{Efficacy boundary scale.  Possible vaues are: Z Scale: 0, p-Value Scale: 1}
#'                      \item{EffBdry}{Vector of efficacy bondaries, one sided tests}
#'                      \item{EffBdryUpper}{Vector of upper efficacy bondaries, two sided tests}
#'                      \item{EffBdryLower}{Vector of lower efficacy boundary, two sided tests}
#'                      \item{FutBdryScale}{Futility boundary scale. Possible value are:  Z Scale: 0, p-Value Scale: 1, Delta Scale: 2, Conditional Power Scale: 3}
#'                      \item{FutBdry}{Vector of futility bondaries, one sided tests.}
#'                      \item{FutBdryUpper}{Vector of upper futility boundaries, two sided tests}
#'                      \item{FutBdryLower}{Vector of lower futility boundaries, two sided tests}
#'                      \item{InterimVisit}{1 based index of the visit which is driving the interims}
#'                      \item{FutContrast}{The contrast based on which futility boundaries are being computed. 0- Primary, 1-Secondary}
#'                      \item{IncludePipeline}{Flag indicating whether to include pipeline subjects in the interim or not. 0- Don't include. 1- Include}
#'                 }
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Required value. Integer Value with the following meaning:
#'                                  \describe{
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is  crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    \item{Decision = 4}{when the Equivalence Boundary Crossed}
#'                                    } 
#'                                    }
#'                  \item{ErrorCode}{ Optional value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                                     
#'                  \item{PrimDelta}{ Float value that gives estimate of Primary contrast delta, 
#'                                    Mandatory If FutBdryScale = 2 (Delta Scale) and FutContrast = 0 (Primary Contrast) 
#'                                    else optional}
#'                  
#'                  \item{SecDelta}{ Float value that gives estimate of Secondary contrast delta 
#'                                  Mandatory if FutBdryScale = 2 (Delta Scale) and FutContrast = 1 (Secondary Contrast)
#'                                  else optional}                 
#'                   
#'                   \item{TestStat}{ Float value, Mandatory If FutBdryScale = 2 (Delta Scale) and FutContrast = 0 (Primary Contrast)}                  
#'                                  { Mandatory If FutBdryScale = 2 (Delta Scale) and FutContrast = 1 (Secondary Contrast)
#'                                  else optional }
#'                      
#'                      }
#'                      
#'                      
Analyze.RepeatedMeasures <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
  # This example is for the case of no dropouts only
  nError <- 0
  nDecision <- 0
  dPrimDelta <- 0
  dSecDelta <- 0
   
  if(  !is.null( LookInfo )  )
  {
    nQtyOfLooks          <- LookInfo$NumLooks
    nLookIndex           <- LookInfo$CurrLookIndex
    nQtyOfPatsForInterim <- LookInfo$CumCompleters[ nLookIndex ]
    nAnalysisVisit       <- LookInfo$InterimVisit
  } else
  {
    nLookIndex           <- 1
    nQtyOfLooks          <- 1
    nQtyOfPatsForInterim <- nrow( SimData )
  }

  dfWideData <- data.frame(id = 1:DesignParam$SampleSize, TreatmentID = SimData$TreatmentID)
  vResponseColumns <- c()
  vVisitTimesColumns <- c()
  for (i in 1:DesignParam$NumVisit) {
      dfWideData[[paste0("Response", i)]] <- SimData[, paste0("Response",i)]
      vResponseColumns <- c(vResponseColumns, paste0("Response", i))
      dfWideData[[paste0("CalendarVisitTime", i)]] <- SimData[,'ArrivalTime'] + SimData[, paste0("ArrTimeVisit", i)]
      vVisitTimesColumns <- c(vVisitTimesColumns, paste0("CalendarVisitTime", i))
  }
  
  dfLongData <- reshape(dfWideData, varying = c(vResponseColumns, vVisitTimesColumns),
                      direction = "long", sep = "", idvar = "id", timevar = "Visit")
  dfLongData <- dfLongData[order(dfLongData$Visit, dfLongData$CalendarVisitTime),]
  
  if(  !is.null( LookInfo )  )
  {
      dAnalysisTime <- dfLongData[dfLongData[['Visit']] == nAnalysisVisit, ][nQtyOfPatsForInterim, "CalendarVisitTime"]
      
      if (LookInfo$IncludePipeline == 0)
      {
          vSubjectsForAnalysis <- unique(dfLongData[dfLongData[['Visit']] == nAnalysisVisit & dfLongData[['CalendarVisitTime']] <= dAnalysisTime, 'id'])
      } else 
      {
          vSubjectsForAnalysis <- unique(dfLongData[dfLongData[['CalendarVisitTime']] <= dAnalysisTime, 'id'])
      }
      
      dfAnalysisData <- dfLongData[dfLongData[['id']] %in% vSubjectsForAnalysis, ]
  } else
  {
      dfAnalysisData <- dfLongData
  }
  
  
  mmrm <- gls(Response ~ TreatmentID,
              na.action = na.omit, data = dfAnalysisData,
              correlation = nlme::corSymm(form = ~ Visit | id),
              weights = nlme::varIdent(form = ~ 1|Visit))
  
  dpValue <- summary(mmrm)$tTable["TreatmentID", "p-value"]
  
  # Get group sequential boundaries
  if( !is.null( LookInfo ) ){
      vGroupSequentialBoundaries <- getDesignGroupSequential(kMax = nQtyOfLooks, alpha = DesignParam$Alpha, sided = 1, typeOfDesign = "OF")
      dAlpha <- vGroupSequentialBoundaries$alphaSpent[nLookIndex]
  } else
  {
      dAlpha <- DesignParam$Alpha
  }
  
  # Set look decision logic
  if( nLookIndex < nQtyOfLooks ) # Interim Analysis
  {
      if( dpValue <= dAlpha )
      {
          strDecision <- "Efficacy"
      }
      else
      {
          strDecision <- "Continue"
      }
  }
  else # Final Analysis
  {
      if( dpValue <= dAlpha )
      {
          strDecision <- "Efficacy"
      }
      else
      {
          strDecision <- "Futility"
      }
  }
  
  nDecision <- GetDecision( strDecision, DesignParam, LookInfo )
  
  return(list(Decision = as.integer(nDecision), PrimDelta = as.double(dPrimDelta), SecDelta = as.double(dSecDelta), ErrorCode = as.integer(nError)))
}
