######################################################################################################################## .
#  Last Modified Date: 05/03/2024
#' AnalyzeUsingEastLogrankFormula
#' @name AnalyzeUsingEastLogrankFormula
#' @title Compute the statistic using formulas Q.242 and Q.243 in the East manual.

#' @description Use the formulas Q.242 and Q.243 in the East manual to compute the statistic.  The purpose of this example is to demonstrate how the analysis and decision making can be modified in a simple approach.  
#'              The test statistic is compared to the lower boundary computed and sent by East as an input. This example does NOT include a futility rule. 

#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'          SimData$ArrivalTime A numeric value with the time the patient arrived in the trial
#'          SimData$TreatmentID An integer value where 0 indicates control treatment and 1 experimental treatment.
#'          SimData$SurvivalTime Numeric value for the survival time or time-to-event for the patient, note this is not the time in the trial
#'                               that the patient experiences the event. 
#' @param DesignParam Input Parameters which user may need to compute test statistic and perform test. 
#'                    User should access the variables using names, for example,  DesignParam$Alpha, and not order. 
#'                    For details of this list please see below. 
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                   LookInfo$NumLooks An integer value with the number of looks in the study
#'                   LookInfo$CurrLookIndex An integer value with the current index look, starting from 1
#'                   LookInfo$InfoFrac A numeric vector containing information fraction
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Required value. Integer Value with the following meaning:
#'                                  \describe{
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is  crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    \item{Decision = 4}{when the Equivalence Boundary Crossed}
#'                                    } 
#'                                    }
#'                  \item{ErrorCode}{Optional integer value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                  \item{Delta}{HazardRatio}{Optional numeric value. 
#'                                            Used in Solara for creating the observed hazard ratio graph. 
#'                                            Only applicable for time-to-event data.}
#'                                            

#'@note Helpful Hints:
#'       There is often info that East sends to R that are not shown in a given example.  It can be very helpful to save the input 
#'       objects and then load them into your R session and inspect them.  This can be done with the following R code in your function.
#'
#'       saveRDS( SimData,     "SimData.Rds")
#'       saveRDS( DesignParam, "DesignParam.Rds" )
#'       saveRDS( LookInfo,    "LookInfo.Rds" )
#'
#'       The above code will save each of the input objects to a file so they may be examined within R.
######################################################################################################################## .

AnalyzeUsingEastLogrankFormula <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
          # saveRDS( SimData,     "SimData.Rds")
          # saveRDS( DesignParam, "DesignParam.Rds" )
          # saveRDS( LookInfo,    "LookInfo.Rds" )
    # Retrieve necessary information from the objects East sent
    if( !is.null( LookInfo ) )
    {
        # Look info was provided so use it
        nQtyOfLooks          <- LookInfo$NumLooks
        nLookIndex           <- LookInfo$CurrLookIndex
        CumEvents            <- LookInfo$InfoFrac*DesignParam$MaxEvents
        nQtyOfEvents         <- CumEvents[ nLookIndex ]
        dEffBdry             <- LookInfo$EffBdryLower[ nLookIndex ]
    }
    else
    {   # Look info is not provided for fixed sample designs so fetch the information appropriately
        nQtyOfLooks          <- 1
        nLookIndex           <- 1
        nQtyOfEvents         <- DesignParam$MaxEvents
        dEffBdry             <- DesignParam$CriticalPoint
    }

    SimData$TimeOfEvent      <- SimData$ArrivalTime + SimData$SurvivalTime    # This is the calendar time in the trial that the patients event is observed
    
    # Compute the time of analysis 
    SimData                  <- SimData[ order( SimData$TimeOfEvent), ]
    dTimeOfAnalysis          <- SimData[ nQtyOfEvents, ]$TimeOfEvent
    
    # Add the Observed Time variable 
    SimData                  <- SimData[ SimData$ArrivalTime <= dTimeOfAnalysis ,]   # Exclude any patients that were not enrolled by the time of the analysis
    SimData$Event            <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, 0, 1 )  # If the event is observed after the analysis it is not observed, eg censored 
    SimData$ObservedTime     <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, dTimeOfAnalysis - SimData$ArrivalTime, SimData$TimeOfEvent - SimData$ArrivalTime )
    
    # Order the data by observed time for the remainder of the computations
    SimData                  <- SimData[ order( SimData$ObservedTime), ]
    
    # Compute Observed HR

    coxModel                 <- coxph(Surv(ObservedTime, Event) ~ TreatmentID, data = SimData)
    dTrueHR                  <- exp(coxModel$coefficients)
    
    SimData$EventOnTreatment <- ifelse(SimData$TreatmentID == 1, SimData$Event, 0) # If the event is observed on treatment
    SimData$EventOnControl   <- ifelse(SimData$TreatmentID == 0, SimData$Event, 0) # If the event is observed on control
    
    # Arm wise count of subjects at risk at the beginning. Is same as arm wise sample size
    nSubjectsAtRiskTreatment <- nrow( SimData[ SimData$TreatmentID == 1, ])
    nSubjectsAtRiskControl   <- nrow( SimData[ SimData$TreatmentID == 0, ])
    
    # Initialize intermediate quantities required for test statistic computation
    dNum <- 0
    dDen <- 0
    
    # Iterate over subjects to calculate dNum and dDen required for test statistic computation
    for ( nSubject in 1:nrow( SimData ) )
    {   # Update the count of subjects at risk for each arm for non event times
        if ( SimData$Event[ nSubject ] == 0 ) 
        {
            if ( SimData$TreatmentID[ nSubject ] == 1 )
            {
                nSubjectsAtRiskTreatment <- nSubjectsAtRiskTreatment - 1
            }
            if ( SimData$TreatmentID[ nSubject ] == 0 )
            {
                nSubjectsAtRiskControl   <- nSubjectsAtRiskControl - 1
            }
            
        } # For subjects with events, compute dNum and dDen
        if ( SimData$Event[ nSubject ] == 1 )
        {
            nEventsOnTreatment           <- SimData$EventOnTreatment[ nSubject ]
            nEventsOnControl             <- SimData$EventOnControl[ nSubject ]
            nEvents                      <- nEventsOnTreatment + nEventsOnControl
            nSubjectsAtRisk              <- nSubjectsAtRiskTreatment + nSubjectsAtRiskControl
            # Equation Q.242 in East Manual
            dNum <- dNum + nEventsOnTreatment - nSubjectsAtRiskTreatment*nEvents/nSubjectsAtRisk
            # Generate dDen based on number of subjects at risk
            if ( nSubjectsAtRisk != 1 )
            {   # Equation Q.243 in East Manual
                dDen <- dDen + nSubjectsAtRiskTreatment*nSubjectsAtRiskControl*( nSubjectsAtRisk - nEvents )*nEvents/( ( nSubjectsAtRisk - 1)*nSubjectsAtRisk^2 )
            }
            # Update the count of subjects at risk before the next iteration
            nSubjectsAtRiskTreatment     <- nSubjectsAtRiskTreatment - nEventsOnTreatment
            nSubjectsAtRiskControl       <- nSubjectsAtRiskControl - nEventsOnControl
        }
    }
    
    # Compute the logrank test statistic
    dTS       <- dNum/sqrt( dDen )
    
    # A decision of 1 means success, 0 means continue the trial
    nDecision <- ifelse( dTS < dEffBdry, 1, 0 )
    
    if( nDecision == 0 )
    {
        # Did not hit efficacy, so check futility 
        # We are at the FA, efficacy decision was not made yet so the decision is futility
        if( nLookIndex == nQtyOfLooks ) 
        {
            nDecision <- 3 # Code for futility 
        }
    }

    Error    <- 0
    
    lRet      <- list(TestStat = as.double( dTS ),
                      Decision  = as.integer( nDecision ), 
                      ErrorCode = as.integer( Error ),
                      HazardRatio = as.double( dTrueHR ))
    return( lRet )
}

