#  Last Modified Date: 11/20/2024
#' @name AnalyzeDualEndpointTTE
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{ArrivalTime}{ A numeric value with the time the patient arrived in the trial}
#'          \item{TreatmentID}{An integer value where 0 indicates control treatment and 1 experimental treatment.}
#'          \item{SurvivalTime}{Numeric value for the survival time or time-to-event for the patient, note this is not the time in the trial
#'                               that the patient experiences the event. }
#'          \item{DropOutTime}{Numeric value for the dropout time for the patient in a time to event trial.}
#'        }
#' @param DesignParam R List which consists of Design and Simulation Parameters which user
#'      may need to compute test statistic and perform test. User should access the variables
#'      using names for eg. DesignParam$Alphae and not order.  Them items are as follows:
#'      \describe{
#'          \item{SampleSize}{Sample size of the trial}
#'          \item{Alpha}{Type I Error}
#'          \item{TestType}{Values are One side: 0; Two Sided: 1, Two Sided, Asymmetric: 2 }
#'          \item{TailType}{Values are Left Tailed: 0, Right Tailed: 1}
#'          \item{LowerAlpha}{Two Sided Asymmetric Tests }
#'          \item{UpperAlpha}{Two Sided Asymmetric Tests }
#'          \item{MaxEvents}{Maximum Events in a time to event based trial}
#'          \item{FollowUpType}{For survival tests, Follow Up Type.  Possible values are: Until End ofS Study: 0, For fixed period: 1}
#'      
#'      }
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                 \describe{
#'                      \item{NumLooks}{An integer value with the number of looks in the study}
#'                      \item{CurrLookIndex}{An integer value with the current index look, starting from 1}
#'                      \item{InfoFrac}{Information fraction}
#'                      \item{CumAlpha}{cumulative alpha spent, one sided tests}
#'                      \item{EffBdryScale}{Efficacy boundary scale.  Possible vaues are: Z Scale: 0, p-Value Scale: 1}
#'                      \item{EffBdry}{Vector of efficacy bondaries, one sided tests}
#'                      \item{EffBdryUpper}{Vector of upper efficacy bondaries, two sided tests}
#'                      \item{EffBdryLower}{Vector of lower efficacy boundary, two sided tests}
#'                      \item{FutBdryScale}{Futility boundary scale. Possible value are:  Z Scale: 0, p-Value Scale: 1, Delta Scale: 2, Conditional Power Scale: 3}
#'                      \item{FutBdry}{Vector of futility bondaries, one sided tests.}
#'                      \item{FutBdryUpper}{Vector of upper futility boundaries, two sided tests}
#'                      \item{FutBdryLower}{Vector of lower futility boundaries, two sided tests}
#'                 }
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Optional value. Integer Value with the following meaning:
#'                                  \describe{
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is  crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    \item{Decision = 4}{when the Equivalence Boundary Crossed}
#'                                    } 
#'                                    }
#'                  \item{TestStat}{Numeric value. Required if Decision is not returned}
#'                  \item{ErrorCode}{Optional integer value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                  \item{Delta}{HazardRatio}{Optional numeric value. 
#'                                            Used in Solara for creating the observed hazard ratio graph. 
#'                                            Only applicable for time-to-event data.}
#'                      }
AnalyzePFSAndOS <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    library(survival)
    library( CyneRgy )
    
    if( !is.null( LookInfo ) )
    {
        nQtyOfLooks  <- LookInfo$NumLooks
        nLookIndex   <- LookInfo$CurrLookIndex
        CumEvents    <- LookInfo$InfoFrac*DesignParam$MaxEvents
        nQtyOfEvents <- CumEvents[ nLookIndex ]
        dEffBdry     <- LookInfo$EffBdryLower[ nLookIndex ]
    }
    else
    {
        nQtyOfLooks  <- 1
        nLookIndex   <- 1
        nQtyOfEvents <- DesignParam$MaxEvents 
        dEffBdry     <- DesignParam$CriticalPoint
    }
    
    # Build the dataset 
    SimData$TimeOfPFSEvent    <- SimData$ArrivalTime + SimData$SurvivalTime    
    SimData$TimeOfOSEvent     <- SimData$ArrivalTime + SimData$OS 
    SimData                   <- SimData[ order( SimData$TimeOfPFSEvent), ]
    dTimeOfAnalysis           <- SimData[ nQtyOfEvents, ]$TimeOfPFSEvent
    SimData                   <- SimData[ SimData$ArrivalTime <= dTimeOfAnalysis ,]   
    
    # Set the PFS event and observed times
    SimData$Event             <- ifelse( SimData$TimeOfPFSEvent > dTimeOfAnalysis, 0, 1 )  
    SimData$ObservedTime      <- ifelse( SimData$TimeOfPFSEvent > dTimeOfAnalysis, dTimeOfAnalysis - SimData$ArrivalTime, SimData$TimeOfPFSEvent - SimData$ArrivalTime )
    
    # Set the OS event and observed times
    SimData$OSEvent             <- ifelse( SimData$TimeOfOSEvent > dTimeOfAnalysis, 0, 1 )  
    SimData$ObservedTimeOS      <- ifelse( SimData$TimeOfOSEvent > dTimeOfAnalysis, dTimeOfAnalysis - SimData$ArrivalTime, SimData$TimeOfOSEvent - SimData$ArrivalTime )
    
    # Analyze the PFS data
    fitCox          <- coxph( Surv( ObservedTime, Event ) ~ as.factor( TreatmentID ), data = SimData )
    dPValuePFS      <- summary(fitCox)$coefficients[,"Pr(>|z|)"]
    dZValPFS        <- summary(fitCox)$coefficients[,"z"]
    dHazardRatioPFS <- exp(coef(fitCox))
    
    # Analyze the OS data
    fitCoxOS        <- coxph( Surv( ObservedTimeOS, Event ) ~ as.factor( TreatmentID ), data = SimData )
    dPValueOS       <- summary(fitCoxOS)$coefficients[,"Pr(>|z|)"]
    dHazardRatioOS  <- exp(coef(fitCoxOS))
    dZValOS         <- summary(fitCoxOS)$coefficients[,"z"]
    
    nPFSEfficacy    <- 0   # 0 if NOT an efficacy decision for PFS, 1 if efficacy decision for PFS
    nOSEfficacy     <- 0   # 0 if NOT an efficacy decision for OS, 1 if efficacy decision for OS
    if( nLookIndex < nQtyOfLooks )  # Interim Analysis
    {
        if( dZValPFS <=dEffBdry  )
        {
            nPFSEfficacy <- 1
        }
        if( dHazardRatioOS < UserParam$HazardRatioCutoffIA )
        {
            nOSEfficacy  <- 1
        }
        
        if( dZValPFS <=dEffBdry && dHazardRatioOS < UserParam$HazardRatioCutoffIA )
        {
            strDecision  <- "Efficacy"
            
        }
        else
        {
            strDecision <- "Continue"
        }
    }
    else # Final Analysis
    {
        
        if( dZValPFS <=dEffBdry  )
        {
            nPFSEfficacy <- 1
        }
        if( dHazardRatioOS < UserParam$HazardRatioCutoffFA )
        {
            nOSEfficacy  <- 1
        }
        
        
        if(  dZValPFS <=dEffBdry && dHazardRatioOS < UserParam$HazardRatioCutoffFA  )
        {
            strDecision  <- "Efficacy"
        }
        else
        {
            strDecision <- "Futility"
        }
    }
    
    nDecision <- CyneRgy::GetDecision( strDecision, DesignParam, LookInfo)
    
    lRet <- list(TestStat   = as.double(dZValPFS),
                 Decision   = as.integer(nDecision), 
                 nPFSEfficacy = as.integer( nPFSEfficacy),
                 nOSEfficacy = as.integer( nOSEfficacy),
                 dPValuePFS = as.double( dPValuePFS ),
                 dZValPFS   = as.double( dZValPFS), 
                 dPValueOS  = as.double( dPValueOS ),
                 dHazardRatioPFS = as.double( dHazardRatioPFS), 
                 dHazardRatioOS = as.double( dHazardRatioOS ),
                 dEffBdry  = as.double( dEffBdry ), 
                 HazardRatioCutoffIA = as.double(UserParam$HazardRatioCutoffIA),
                 HazardRatioCutoffFA = as.double( UserParam$HazardRatioCutoffFA ),
                 ErrorCode = as.integer(0),
                 HazardRatio = as.double(dHazardRatioPFS ))
    
    return( lRet )
}
