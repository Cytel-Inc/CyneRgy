#' @name AnalyzeUsingLogrankTestBonferroni
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{ArrivalTime}{A numeric value with the time the patient arrived in the trial}
#'          \item{TreatmentID}{An integer value specifying the index of arms to which subjects are allocated (one arm index per subject). Index for control is 0}
#'          \item{SurvivalTime}{Numeric value for the survival time or time-to-event for the patient, note this is not the time in the trial
#'                               that the patient experiences the event.}
#'          \item{DropOutTime}{Numeric value for the dropout time for the patient in a time to event trial.}
#'        }
#' @param DesignParam R List which consists of Design and Simulation Parameters which user
#'      may need to compute test statistic and perform test. User should access the variables
#'      using names for e.g., DesignParam$Alpha and not order. Them items are as follows:
#'      \describe{
#'          \item{SampleSize}{Integer. Sample size of the trial}
#'          \item{Alpha}{Numeric. Type I Error}
#'          \item{TrialType}{Integer. Type of the Trial. Values are Superiority: 0}
#'          \item{TestType}{Integer. Values are One side: 0}
#'          \item{TailType}{Integer. Values are Left Tailed: 0, Right Tailed: 1}
#'          \item{InitialAllocInfo}{Vector of the ratios of the treatment group sample sizes to control group sample size. Length = number of treatment arms.}
#'          \item{TestID}{Integer. Test ID. Values are Difference of Proportions: 303}
#'          \item{MultAdjMethod}{Integer. Multiple Comparison Procedure. Values are Bonferroni: 0, Weighted Bonferroni: 2, Hochberg's Step Up: 4, Fixed Sequence: 6, Fallback: 7}
#'          \item{NumTreatments}{Integer. Number of Treatment arms}
#'          \item{AlphaProp}{Vector of Proportions of Alpha for each treatment arm}
#'          \item{TestSeq}{Vector of integer Test Sequence for each comparison which corresponds to each treatment arm.}
#'          \item{CriticalPoint}{Numeric. Critical Value for a fixed sample design.}
#'          \item{IsArmPresent}{Vector of integer flags indicating whether an arm is still present in the trial or was dropped in the interim. Length = number of treatment arms. Values are - Dropped in the interim: 0, Still present in the trial: 1}
#'          \item{UpdatedAllocInfo}{Vector of ratios of the treatment group sample sizes to control group sample size which may have been updated during treatment selection. Length = number of treatment arms.}
#'          \item{MaxEvents}{Integer. Maximum Events.}
#'          \item{FollowUpType}{Integer. Follow up Type. Values are Until end of the study: 0, For fixed period: 1}
#'          \item{FollowUpDur}{Numeric. Follow up duration.}
#'      
#'      }
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                 \describe{
#'                      \item{NumLooks}{An integer value with the number of looks in the study.}
#'                      \item{CurrLookIndex}{An integer value with the current index look, starting from 1.}
#'                      \item{CumEvents}{Vector of Cumulative events. Length = Number of looks.}
#'                      \item{InfoFrac}{Vector of numeric Information fraction. Length = Number of looks.}
#'                      \item{CumAlpha}{Vector of numeric Cumulative alpha spent, one sided tests. Length = Number of looks.}
#'                      \item{EffBdryScale}{Integer. Efficacy boundary scale. Possible vaues are: Z Scale: 0}
#'                      \item{EffBdry}{Vector of numeric efficacy boundaries, one sided tests. Length = Number of looks.}
#'                      \item{FutBdryScale}{Integer. Futility boundary scale. Possible value are: HR Scale: 6}
#'                      \item{FutBdry}{Vector of numeric futility bondaries, one sided tests. Length = Number of looks.}
#'                      \item{RejType}{Integer. Rejection Type. Values are: 1 Sided Efficacy Upper: 0, 1 Sided Futility Upper: 1, 1 Sided Efficacy Lower: 2, 1 Sided Futility Lower: 3, 1 Sided Efficacy Upper Futility Lower: 4, 1 Sided Efficacy Lower Futility Upper: 5}
#'                 }
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Vector of Integers or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if Decision is returned. Values have the following meaning:
#'                                  \describe{
#'                                    \item{Decision = NA}{When the arm is dropped in a previous look}
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    }
#'                                    }
#'                  \item{AdjPVal}{p-Value adjusted for MCP adjustment. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if AdjPVal is returned and if there is no Futility Boundary.}
#'                  \item{RawPVal}{p-Value computed from test statistics. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if RawPVal is returned and if there is no Futility Boundary.}
#'                  \item{TestStat}{Value of appropriate Test Statistic on Wald ﴾Z﴿ scale regardless of the Efficacy or Futility Boundary Scale for each Treatment Arm. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if TestStat is returned and if there is no Futility Boundary.}
#'                  \item{HR}{Estimate of Hazard Ratio for each Treatment Arm. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. Required if Decision is not returned AND Futility Boundary scale is HR}
#'                  \item{ErrorCode}{Integer. Optional value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Nonfatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                      }
AnalyzeUsingLogrankTestBonferroni <- function( SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    # Retrieve necessary information from the objects East Horizon sent
    if( !is.null( LookInfo ) )
    {
        # Look info was provided so use it
        nQtyOfLooks              <- LookInfo$NumLooks
        nLookIndex               <- LookInfo$CurrLookIndex
        CumEvents                <- LookInfo$InfoFrac*DesignParam$MaxEvents
        nQtyOfEvents             <- CumEvents[ nLookIndex ]
        vInfoFrac                <- LookInfo$InfoFrac
        vEfficacyBoundary        <- gsDesign::gsDesign( k = nQtyOfLooks, test.type = 1, alpha = DesignParam$Alpha, 
                                                       sfu = gsDesign::sfLDOF, timing = vInfoFrac )
        vEfficacyBoundaryPScale  <- 1 - pnorm(vEfficacyBoundary$upper$bound)
    }
    else
    {   # Look info is not provided for fixed sample designs so fetch the information appropriately
        nQtyOfLooks              <- 1
        nLookIndex               <- 1
        nQtyOfEvents             <- DesignParam$MaxEvents
        dEffBdry                 <- DesignParam$CriticalPoint
        vInfoFrac                <- 1
        vEfficacyBoundaryPScale  <- DesignParam$Alpha
    }
    vIsTrtPresent                <- DesignParam$IsArmPresent[-1]
    
    SimData$TimeOfEvent          <- SimData$ArrivalTime + SimData$SurvivalTime    # This is the calendar time in the trial that the patients event is observed
    
    # Compute the time of analysis 
    SimData                      <- SimData[ order( SimData$TimeOfEvent), ]
    dTimeOfAnalysis              <- SimData[ nQtyOfEvents, ]$TimeOfEvent
    
    # Add the Observed Time variable 
    SimData                      <- SimData[ SimData$ArrivalTime <= dTimeOfAnalysis ,]   # Exclude any patients that were not enrolled by the time of the analysis
    SimData$Event                <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, 0, 1 )  # If the event is observed after the analysis it is not observed, eg censored 
    SimData$ObservedTime         <- ifelse( SimData$TimeOfEvent > dTimeOfAnalysis, dTimeOfAnalysis - SimData$ArrivalTime, SimData$TimeOfEvent - SimData$ArrivalTime )
    
    # Order the data by observed time for the remainder of the computations
    SimData                      <- SimData[ order( SimData$ObservedTime ), ]
    
    vPValues                     <- rep( NA, DesignParam$NumTreatments )
    vHRRatio                     <- rep( NA, DesignParam$NumTreatments )
    for (nTrtID in 1:DesignParam$NumTreatments){
        if (vIsTrtPresent[ nTrtID ] == 1){
            SimDataTrt           <- SimData[ SimData$TreatmentID %in% c(0, nTrtID), ]
            # Compute Observed HR
            coxModel             <- coxph( Surv( ObservedTime, Event ) ~ TreatmentID, data = SimDataTrt)
            dTrueHR              <- exp( coxModel$coefficients )
            
            # Compute the test statistic using survival package
            logrankTest          <- survdiff( Surv( ObservedTime, Event ) ~ TreatmentID, SimDataTrt)
            
            # Compute the logrank test statistic
            dPValue              <- logrankTest$pvalue
        } else
        {
            dTrueHR              <- NA
            dPValue              <- NA
        }
        vHRRatio[nTrtID]         <- dTrueHR
        vPValues[nTrtID]         <- dPValue
    }
    
    # Calculate Bonferroni adjusted p values
    # Assumes that each present arm has a valid hypothesis test and p-value
    vAdjPValues                  <- vPValues * sum( vIsTrtPresent ) 
    
    # Perform the desired analysis. NA should be returned for arms that are not available at this look
    vDecision                    <- ifelse( vAdjPValues < vEfficacyBoundaryPScale[ nLookIndex ], 2, 0 )  # A decision of 2 means success, 0 means continue the trial
    
    for( i in 1:length( vDecision ) ){
        if( vDecision[i] == 0 )
        {
            # Did not hit efficacy, so check futility 
            # We are at the FA, efficacy decision was not made yet so the decision is futility
            if( nLookIndex == nQtyOfLooks ) 
            {
                vDecision[i]     <- 3 # Code for futility 
            }
        }
    }
    
    nError 	                     <- 0
    
    return( list(Decision  = as.integer( vDecision ), 
                 ErrorCode = as.integer( nError ),
                 HazardRatio = as.numeric( vHRRatio )) )
}

