######################################################################################################################## .
#' @name AnalyzeUsingPropTestBonferroni
#' @title Analyze using the prop.test function in base R.
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{ArrivalTime}{A numeric value with the time the patient arrived in the trial}
#'          \item{TreatmentID}{An integer value specifying the index of arms to which subjects are allocated (one arm index per subject). Index for control is 0}
#'          \item{Response}{An integer value where 1 indicates response and 0 indicates no response.}
#'          \item{CensorInd}{An integer value indicating whether the subject was censored or not.}
#'        }
#' @param DesignParam R List which consists of Design and Simulation Parameters which user
#'      may need to compute test statistic and perform test. User should access the variables
#'      using names for e.g., DesignParam$Alpha and not order. Them items are as follows:
#'      \describe{
#'          \item{SampleSize}{Integer. Sample size of the trial}
#'          \item{Alpha}{Numeric. Type I Error}
#'          \item{TrialType}{Integer. Type of the Trial. Values are Superiority: 0}
#'          \item{TestType}{Integer. Values are One side: 0}
#'          \item{TailType}{Integer. Values are Left Tailed: 0, Right Tailed: 1}
#'          \item{InitialAllocInfo}{Vector of the ratios of the treatment group sample sizes to control group sample size. Length = number of treatment arms.}
#'          \item{VarType}{Integer. Variance Type. Values are Pooled: 0, Unpooled: 1}
#'          \item{TestID}{Integer. Test ID. Values are Difference of Proportions: 303}
#'          \item{MultAdjMethod}{Integer. Multiple Comparison Procedure. Values are Bonferroni: 0, Weighted Bonferroni: 2, Hochberg's Step Up: 4, Fixed Sequence: 6, Fallback: 7}
#'          \item{NumTreatments}{Integer. Number of Treatment arms}
#'          \item{AlphaProp}{Vector of Proportions of Alpha for each treatment arm}
#'          \item{TestSeq}{Vector of integer Test Sequence for each comparison which corresponds to each treatment arm.}
#'          \item{MaxCompleters}{Integer. Maximum Number of Completers.}
#'          \item{CriticalPoint}{Numeric. Critical Value for a fixed sample design.}
#'          \item{RespLag}{Numeric. Follow up duration.}
#'          \item{IsArmPresent}{Vector of integer flags indicating whether an arm is still present in the trial or was dropped in the interim. Length = number of treatment arms. Values are - Dropped in the interim: 0, Still present in the trial: 1}
#'          \item{UpdatedAllocInfo}{Vector of ratios of the treatment group sample sizes to control group sample size which may have been updated during treatment selection. Length = number of treatment arms.}
#'      
#'      }
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                 \describe{
#'                      \item{NumLooks}{An integer value with the number of looks in the study.}
#'                      \item{CurrLookIndex}{An integer value with the current index look, starting from 1.}
#'                      \item{CumCompleters}{Vector of Cumulative number of completer for all non time-to-event studies. Length = Number of looks.}
#'                      \item{InfoFrac}{Vector of numeric Information fraction. Length = Number of looks.}
#'                      \item{CumAlpha}{Vector of numeric Cumulative alpha spent, one sided tests. Length = Number of looks.}
#'                      \item{EffBdryScale}{Integer. Efficacy boundary scale. Possible vaues are: Z Scale: 0}
#'                      \item{EffBdry}{Vector of numeric efficacy bondaries, one sided tests. Length = Number of looks.}
#'                      \item{FutBdryScale}{Integer. Futility boundary scale. Possible value are: Delta Scale: 2}
#'                      \item{FutBdry}{Vector of numeric futility bondaries, one sided tests. Length = Number of looks.}
#'                      \item{RejType}{Integer. Rejection Type. Values are: 1 Sided Efficacy Upper: 0, 1 Sided Futility Upper: 1, 1 Sided Efficacy Lower: 2, 1 Sided Futility Lower: 3, 1 Sided Efficacy Upper Futility Lower: 4, 1 Sided Efficacy Lower Futility Upper: 5}
#'                 }
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Vector of Integers or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if Decision is returned. Values have the following meaning:
#'                                  \describe{
#'                                    \item{Decision = NA}{When the arm is dropped in a previous look}
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    }
#'                                    }
#'                  \item{AdjPVal}{p-Value adjusted for MCP adjustment. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if AdjPVal is returned and if there is no Futility Boundary.}
#'                  \item{RawPVal}{p-Value computed from test statistics. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if RawPVal is returned and if there is no Futility Boundary.}
#'                  \item{TestStat}{Value of appropriate Test Statistic on Wald ﴾Z﴿ scale regardless of the Efficacy or Futility Boundary Scale for each Treatment Arm. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if TestStat is returned and if there is no Futility Boundary.}
#'                  \item{Delta}{Estimate of Delta (Difference from Control) for each Treatment Arm. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. Required if Decision is not returned AND Futility Boundary scale is Delta.}
#'                  \item{ErrorCode}{Integer. Optional value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Nonfatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                      }
AnalyzeUsingPropTestBonferroni <- function( SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    # Step 1: Retrieve necessary information from the objects East sent ####
    if(  !is.null( LookInfo )  )
    {
        nQtyOfLooks              <- LookInfo$NumLooks
        nLookIndex               <- LookInfo$CurrLookIndex
        nQtyOfPatsInAnalysis     <- LookInfo$CumCompleters[ nLookIndex ]
        vInfoFrac                <- LookInfo$InfoFrac
        vEfficacyBoundary        <- gsDesign::gsDesign(k = nQtyOfLooks, test.type = 1, alpha = DesignParam$Alpha, 
                                                sfu = gsDesign::sfLDOF, timing = vInfoFrac)
        vEfficacyBoundaryPScale  <- 1 - pnorm(vEfficacyBoundary$upper$bound)
    }
    else
    {
        nQtyOfLooks              <- 1
        nLookIndex               <- 1
        nQtyOfPatsInAnalysis     <- nrow( SimData )
        vInfoFrac                <- 1
        vEfficacyBoundaryPScale  <- DesignParam$Alpha
    }
    
    vIsTrtPresent                <- DesignParam$IsArmPresent
    # Create the vector of simulated data for this IA - East sends all of the simulated data
    vPatientOutcome              <- SimData$Response[ 1:nQtyOfPatsInAnalysis ]
    vPatientTreatment            <- SimData$TreatmentID[ 1:nQtyOfPatsInAnalysis ]
    
    # Create vector of data for control 
    vOutcomesS                   <- vPatientOutcome[ vPatientTreatment == 0 ]
    
    # Calculate p-value for each hypothesis. Return NA if arm not present in the current analysis
    vPValues <- rep( NA, DesignParam$NumTreatments )
    for( nTrtID in 1:DesignParam$NumTreatments ){
        if (vIsTrtPresent[ nTrtID ] == 1){
            vOutcomesE           <- vPatientOutcome[ vPatientTreatment == nTrtID ]
            mData                <- cbind(table(vOutcomesS), table(vOutcomesE))
            lAnalysisResult      <- prop.test(mData, alternative = "greater", correct = FALSE)
            dPValue              <- lAnalysisResult$p.value
        } else
        {
            dPValue              <- NA
        }
        vPValues[nTrtID]         <- dPValue
    }
    
    # Calculate Bonferroni adjusted p values
    vAdjPValues                  <- vPValues * sum( vIsTrtPresent ) 

    # Perform the desired analysis. NA should be returned for arms that are not available at this look
    # vDecision                    <- ifelse( vAdjPValues < vEfficacyBoundaryPScale[ nLookIndex], 2, 0 )  # A decision of 2 means success, 0 means continue the trial
    vDecision <- c()
    for ( i in 1:length(vAdjPValues) ){
        strDecision <- CyneRgy::GetDecisionString( LookInfo, nLookIndex, nQtyOfLooks, 
                                                   bIAEfficacyCondition = vAdjPValues[i] < vEfficacyBoundaryPScale[ nLookIndex ], 
                                                   bFAEfficacyCondition = vAdjPValues[i] < vEfficacyBoundaryPScale[ nLookIndex ])
        nDecision <- CyneRgy::GetDecision( strDecision, DesignParam, LookInfo )
        vDecision <- c(vDecision, nDecision)
    }
    # for( i in 1:length(vDecision) ){
    #     if( vDecision[i] == 0 )
    #     {
    #         # Did not hit efficacy, so check futility 
    #         # We are at the FA, efficacy decision was not made yet so the decision is futility
    #         if( nLookIndex == nQtyOfLooks ) 
    #         {
    #             vDecision[i]     <- 3 # Code for futility 
    #         }
    #     }
    # }
    
    nError 	                     <- 0
    
    return( list(Decision  = as.integer(vDecision), 
                 ErrorCode = as.integer(nError)) )
}

