######################################################################################################################## .
#' @name  AnalyzeMultipleOutcomesCovariatesStratRandomization
#' @title Analyze Simulated Patient Data with Multiple Independent Outcomes and Stratified Randomization
#' 
#' @description This function performs statistical analysis on simulated patient-level data with multiple continuous endpoints, binary 
#' covariates and stratified randomization. For each endpoint, it fits an ANCOVA model to assess the treatment effect while adjusting 
#' for covariates. The function returns binary decisions for treatment and covariate effects, along with group-wise means and sample sizes.
#' The output of this function is generated dynamically based on the number of covariates and endpoints, but it follows the same logic 
#' as the explicitly constructed output list in `AnalyzeMultipleOutcomes.R`.
#' 
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. It will have headers indicating 
#' the names of the columns. These names will be same as those used in Data Generation. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{PatientOutcome[X]}{Numeric vector representing results for endpoint X, where X = 1, 2, 3}
#'          \item{Covariate[Y]}{Binary vector representing results for covariate Y, where Y = 1, 2}
#'          \item{PatientTreatmentID}{Integer vector (0 = control, 1 = treatment). Note that this vector was generated by 
#'          `SimulateMultipleOutcomesCovariatesStratRandomization` function, not native East Horizon}
#'        }          
#' @param DesignParam R List which consists of Design and Simulation Parameters which user may need to compute test statistic and perform 
#' test. For analysis the most relevant variable is:
#'        \describe
#'        {
#'          \item{Alpha}{1-sided Type I Error. Note it will be internally converted to two-sided (i.e., 2 Ã— Alpha) for ANCOVA.}
#'        } 
#' @param LookInfo List. Not used in this function.
#' @param UserParam List. Not used in this function.     
#'        
#' @return A named list containing elements as described below. Note that the return list expands dynamically depending on the 
#' number of endpoints (X) and covariates (Y).
#'        \describe
#'        {
#'          \item{Decision}{Placeholder value (always 1)}
#'          \item{SampleSizeCtrl}{Number of patients in the control group}
#'          \item{SampleSizeTrt}{Number of patients in the treatment group}
#'          \item{MeanOutcome[X]Ctrl}{Mean outcome for the control group for endpoint X}
#'          \item{MeanOutcome[X]Trt}{Mean outcome for the treatment group for endpoint X}
#'          \item{DecisionOutcome[X]Trt}{Binary decisions (1 = significant, 0 = not significant) for treatment effect for endpoint X}
#'          \item{DecisionOutcome[X]Covariate[Y]}{Binary decisions (1 = significant, 0 = not significant) for endpoint X for covariate Y}
#'          \item{PValueOutcome[X]Trt}{p-value for endpoint X for treatment}
#'          \item{PValueOutcome[X]Covariate[Y]} {p-value for endpoint X for covariate Y}
#'        }   
#' @examples
#' 
#' # Simulate patient data with three independent outcomes, two covariates and stratified randomization
#' UserParam   <- list(MeanOutcome1Ctrl = 10, MeanOutcome1Trt = 12,
#'                     MeanOutcome2Ctrl = 20, MeanOutcome2Trt = 22,
#'                     MeanOutcome3Ctrl = 30, MeanOutcome3Trt = 32,
#'                     Beta1 = 0.1, Beta2 = 2,
#'                     Cov1Prob = 0.2, Cov2Prob = 0.5,
#'                     AllocRatio = 1)
#'                     
#' NumSub      <- 100
#'
#' response    <- SimulateMultipleOutcomesCovariatesStratRandomization(NumSub = NumSub, 
#'                                                                     TreatmentID = NULL,
#'                                                                     Mean = NULL, 
#'                                                                     StdDev = NULL, 
#'                                                                     UserParam = UserParam)
#' 
#' # Change the format of the simulated data (this is only required for testing the code in R, outside of East Horizon)                                                                       
#' response_df <- as.data.frame(response[c("PatientOutcome1", "PatientOutcome2", "PatientOutcome3", 
#'                                         "Covariate1", "Covariate2", 
#'                                         "PatientTreatmentID")])
#' 
#' # Analyze the simulated patient data                                                              
#' result <-  AnalyzeMultipleOutcomesCovariatesStratRandomization(SimData = response_df,
#'                                                                DesignParam = list("Alpha" = 0.05))                                                          
#'
#' @export

######################################################################################################################## .

AnalyzeMultipleOutcomesCovariatesStratRandomization <- function( SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    
    library( broom )
    
    # Extract 1-sided Type I error and transform it into two-sided for ANCOVA
    dAlphaOneSided   <- DesignParam$Alpha
    dAlphaTwoSided   <- dAlphaOneSided * 2
    
    # Extract outcomes and covariates
    lPatientOutcomes <- as.list( SimData[ , grep( "PatientOutcome", names( SimData ) ) ] )
    lCovariates      <- as.list( SimData[ , grep( "Covariate", names( SimData ) ) ] )
    
    # Determine number of endpoints and covariates
    nQtyOfEndpoints  <- length( lPatientOutcomes )
    nQtyOfCovariates <- length( lCovariates )
    
    # Create a vector of treatment assignments generated through stratified randomization
    vTreatmentID     <- SimData$PatientTreatmentID
    
    # Determine the number of patients in each group
    nSampleSizeCtrl  <- sum( vTreatmentID == 0 )
    nSampleSizeTrt   <- sum( vTreatmentID == 1 )
    
    # Initialize lists and vectors to store results for each endpoint
    lPValues         <- vector( "list", nQtyOfEndpoints )
    lDecision        <- vector( "list", nQtyOfEndpoints )
    
    vMeanOutcomeCtrl <- numeric( nQtyOfEndpoints )
    vMeanOutcomeTrt  <- numeric( nQtyOfEndpoints )

    # Run separate ANCOVA for each endpoint
    for ( i in 1:nQtyOfEndpoints )
    {
        # Compute group means
        vMeanOutcomeCtrl[ i ]  <- mean( lPatientOutcomes[[ i ]][ vTreatmentID == 0 ] )
        vMeanOutcomeTrt [ i ]  <- mean( lPatientOutcomes[[ i ]][ vTreatmentID == 1 ] )
        
        # Build formula dynamically: outcome ~ TreatmentID + Covariate 1 + Covariate 2 
        strPartOfFormula <- paste( c( "vTreatmentID", paste0( "lCovariates[[ ", seq_len( nQtyOfCovariates ), " ]]" ) ),
                                   collapse = " + " )
        strFormula       <- as.formula( paste( "lPatientOutcomes[[ i ]] ~", strPartOfFormula ) )
        
        # Perform ANCOVA
        dfAnalysisResult <- broom::tidy( aov( strFormula ) )
        
        # Extract the p values. Note that the last value is for residuals
        lPValues [[ i ]] <- head( dfAnalysisResult$p.value, -1 )
        lDecision[[ i ]] <- as.integer( lPValues [[ i ]] <= dAlphaTwoSided )
    } 
    
    # Return the analysis results, sample sizes of each group and means of outcomes
    lReturn <- list( Decision       = as.integer( 1 ),
                     SampleSizeCtrl = as.integer( nSampleSizeCtrl ),
                     SampleSizeTrt  = as.integer( nSampleSizeTrt ) )
    
    # Add mean outcome and treatment decision 
    for ( i in 1:nQtyOfEndpoints ) 
    {
        lReturn[[ paste0( "MeanOutcome", i, "Ctrl" ) ]]    <- as.double( vMeanOutcomeCtrl[ i ] )
        lReturn[[ paste0( "MeanOutcome", i, "Trt" ) ]]     <- as.double( vMeanOutcomeTrt[ i ] )
        lReturn[[ paste0( "PValueOutcome", i , "Trt" ) ]]  <- as.double( lPValues [[ i ]][ 1 ] )
        lReturn[[ paste0( "DecisionOutcome", i, "Trt" ) ]] <- as.integer( lDecision[[ i ]][ 1 ] )
        
    }
    
    # Add p-values and covariate decisions 
    for ( j in 1:nQtyOfCovariates ) 
    {
        for ( i in 1:nQtyOfEndpoints ) 
        {
            lReturn[[ paste0( "PValueOutcome", i, "Covariate", j ) ]]   <- as.double ( lPValues [[ i ]][ j+1 ] )
            lReturn[[ paste0( "DecisionOutcome", i, "Covariate", j ) ]] <- as.integer( lDecision[[ i ]][ j+1 ] )
            
        }
    }
    
    return( lReturn )
    
 }
 