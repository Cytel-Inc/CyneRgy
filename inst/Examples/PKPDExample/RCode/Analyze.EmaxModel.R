#' Last Modified Date: 08/15/2025
#' @name Analyze.EmaxModel
#' @description Analyzes repeated measures responses generated from the Emax model. Fits a repeated measures model 
#'              to assess the treatment effect, optionally at interim looks for group sequential designs, and 
#'              generates a decision code based on efficacy/futility boundaries.
#' 
#' @param SimData Data frame with patient responses generated by GenerateResponseEmaxModel, one row per subject.
#'        Columns include:
#'        \describe{
#'          \item{TreatmentID}{Integer value where 0 indicates control and 1 indicates treatment.}
#'          \item{Response[VisitID]}{Numeric response for each visit, as generated by GenerateResponseEmaxModel.}
#'        }
#' @param DesignParam List containing trial design parameters required for analysis:
#'        \describe{
#'          \item{SampleSize}{Total sample size of the trial.}
#'          \item{Alpha}{Type I error rate.}
#'          \item{NumVisit}{Number of visits.}
#'          \item{TailType}{0 = Left-tailed, 1 = Right-tailed.}
#'          \item{Other relevant parameters for contrasts or stopping rules.}
#'        }
#' @param LookInfo Optional list for interim or group sequential analysis:
#'        \describe{
#'          \item{NumLooks}{Number of looks in the study.}
#'          \item{CurrLookIndex}{Current look index (1-based).}
#'          \item{CumCompleters}{Cumulative number of completers up to the current look.}
#'          \item{InterimVisit}{Visit driving the interim analysis.}
#'          \item{IncludePipeline}{0 = exclude pipeline subjects, 1 = include.}
#'        }
#' @param UserParam Optional list of user-defined scalar parameters. Can include any custom variables required
#'                  for effect calculations or post-hoc analyses.
#' 
#' @return List containing:
#'        \describe{
#'          \item{Decision}{Integer decision code:
#'                 0 = No boundary crossed
#'                 1 = Lower efficacy boundary crossed
#'                 2 = Upper efficacy boundary crossed
#'                 3 = Futility boundary crossed
#'                 4 = Equivalence boundary crossed
#'          }
#'          \item{PrimDelta}{Estimated primary contrast delta (currently placeholder = 0).}
#'          \item{SecDelta}{Estimated secondary contrast delta (currently placeholder = 0).}
#'          \item{ErrorCode}{Integer error code:
#'                 0 = no error,
#'                 >0 = nonfatal error,
#'                 <0 = fatal error
#'          }
#'        }

Analyze.EmaxModel <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL) {
    
    library(nlme)
    library(CyneRgy)  # Needed for decision helpers
    
    
    nError <- 0
    nDecision <- 0
    dPrimDelta <- 0
    dSecDelta <- 0
    
    # Step 1: Handle LookInfo (Interim Analysis)
    if (!is.null(LookInfo)) {
        nQtyOfLooks          <- LookInfo$NumLooks
        nLookIndex           <- LookInfo$CurrLookIndex
        nQtyOfPatsForInterim <- LookInfo$CumCompleters[ nLookIndex ]
        nAnalysisVisit       <- LookInfo$InterimVisit
    } else {
        nLookIndex           <- 1
        nQtyOfLooks          <- 1
        nQtyOfPatsForInterim <- nrow(SimData)
    }
    
    # Step 2: Wide â†’ Long format ------------------------------------
    dfWideData <- data.frame(id = 1:DesignParam$SampleSize,
                             TreatmentID = SimData$TreatmentID)
    vResponseColumns <- c()
    
    for (i in 1:DesignParam$NumVisit) {
        dfWideData[[paste0("Response", i)]] <- SimData[[paste0("Response", i)]]
        vResponseColumns <- c(vResponseColumns, paste0("Response", i))
    }
    
    dfLongData <- reshape(dfWideData, varying = vResponseColumns,
                          direction = "long", sep = "", idvar = "id", timevar = "Visit")
    dfLongData <- dfLongData[ order(dfLongData$id, dfLongData$Visit), ]
    
    dfLongData$TreatmentID <- factor(dfLongData$TReatmentID)
    
    # Step 3: Interim subject filtering ----------------------------
    if (!is.null(LookInfo)) {
        dfAnalysisData <- dfLongData[dfLongData$id <= nQtyOfPatsForInterim, ]
    } else {
        dfAnalysisData <- dfLongData
    }
    
    # Step 4: Fit Repeated Measures Model --------------------------
    mmrm <- gls(Response ~ TreatmentID * factor(Visit),
                na.action = na.omit, data = dfAnalysisData,
                correlation = corSymm(form = ~ Visit | id),
                weights = varIdent(form = ~ 1 | Visit))
    dpValue <- summary(mmrm)$tTable["TreatmentID", "p-value"]
    
    # Step 5: Alpha for this look -----------------------------------
    if (!is.null(LookInfo)) {
        vBounds <- getDesignGroupSequential(kMax = nQtyOfLooks,
                                            alpha = DesignParam$Alpha,
                                            sided = 1, typeOfDesign = "OF")
        dAlpha <- vBounds$alphaSpent[nLookIndex]
    } else {
        dAlpha <- DesignParam$Alpha
    }
    
    # Step 6: Make decision -----------------------------------------
    strDecision <- CyneRgy::GetDecisionString(LookInfo, nLookIndex, nQtyOfLooks,
                                              bIAEfficacyCondition = dpValue <= dAlpha,
                                              bFAEfficacyCondition = dpValue <= dAlpha)
    nDecision <- CyneRgy::GetDecision(strDecision, DesignParam, LookInfo)
    
    # Step 7: Return -------------------------------------------------
    return(list(
        Decision  = as.integer(nDecision),
        PrimDelta = as.double(dPrimDelta),
        SecDelta  = as.double(dSecDelta),
        ErrorCode = as.integer(nError)
    ))
}