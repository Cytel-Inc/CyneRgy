######################################################################################################################## .
#  Last Modified Date: 22/09/2025
#' @name AnalyzeUsingFisherExactTest
#' @author Pradip Maske
#' @title Fisher exact test for binary endpoint.
#'
#' @description Compute the Fisher exact test for binary endpoint given simulation data. 
#'
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'          SimData$ArrivalTime   :   A numeric value with the time the patient arrived in the trial.
#'          SimData$TreatmentID   :   An integer value where 0 indicates control treatment and 1 experimental treatment.
#'          SimData$ResponseX     :   A numeric value (0:Non-responder/1:Responder) for the binary response.
#'          SimData$ClndrRespTimeX:   A numeric value representing Calendar Response Time of a patient, i.e., time to response since trial start
#'          SimData$CensorIndOrgX :   A numeric value representing censoring status (0:Censored/1: Completer)
#' @param DesignParam Input Parameters which user may need to compute test statistic and perform test. 
#'                    User should access the variables using names, for example,  DesignParam$Alpha, and not order. 
#'                    For details of this list please see below. 
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                   LookInfo$NumLooks      :   An integer value with the number of looks in the study
#'                   LookInfo$CurrLookIndex :   An integer value with the current index look, starting from 1
#'                   LookInfo$InfoFrac      :   A numeric vector containing information fraction
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{TestStat}{Required value. Test statistic on Z-scale.}
#'                  \item{ErrorCode}{Optional integer value \describe{
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }}
#'                  \item{Delta}{Required numeric value - Delta,
#'                            Only applicable for binary/continuous data.}
#'             }
#'
#'
#' @note The current code assumes there are no dropouts. Modify the code accordingly for dropout case.
######################################################################################################################## .

AnalyzeUsingFisherExactTest <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
  
  # The endpoint ID and name of the endpoint to be analysed.
  # This needs to be manually specified as of now
  anlysEPID       <- 2
  anlysEPName     <- DesignParam$EndpointName[anlysEPID]

  AnalysisTime    <- ComputeDEPAnalysisTime(SimData, DesignParam, LookInfo)     
  SimDataForAnlys <- SimData[SimData$ArrivalTime <= AnalysisTime, ]             #Slicing the data to be used for analysis
  
  # Create the vector of simulated data for this interim analysis
  vPatientOutcome      <- SimDataForAnlys[[paste0("Response", anlysEPID)]]
  vPatientTreatment    <- SimDataForAnlys$TreatmentID
  
  # Create contingency table for Fisher's Exact Test
  mContingencyTable    <- table(vPatientTreatment, vPatientOutcome)
  
  # Perform Fisher's Exact Test
  if(DesignParam$TailType[[anlysEPID]] == 0) 
  {
    fisherResult <- fisher.test(mContingencyTable, alternative = "less")
  }
  else 
  {
    fisherResult <- fisher.test(mContingencyTable, alternative = "greater")
  }
  
  dPValue      <- fisherResult$p.value
  
  # Convert p-value to standard normal quantile
  dZValue <- qnorm(1 - dPValue)
  PiC <- mContingencyTable[1,][2] / apply(mContingencyTable, 1, sum)[1]
  PiT <- mContingencyTable[2,][2] / apply(mContingencyTable, 1, sum)[2]
  Error    <- 0
  
  return( list(TestStat = as.double( dZValue ),
               Delta = as.double( PiT - PiC ),
               ErrorCode = as.integer( Error )) )
}


#ComputeDEPAnalysisTime() : Function to compute the analysis time for DEP. 
ComputeDEPAnalysisTime <- function(SimData, DesignParam, LookInfo = NULL) 
{
  
  bGSD <- ifelse(is.null(LookInfo), FALSE, TRUE)                                # Is the trial using Group sequential Design?
  
  if(bGSD)               # Group Sequential Design   
  {
    syncEPID <- LookInfo$SyncInterim                                            # Endpoint ID for the endpoint to be used for look positioning
    syncEPType <- DesignParam$EndpointType[[syncEPID]]                          # Endpoint type of the endpoint used for look positioning
    nonsyncEPID <- ifelse(LookInfo$SyncInterim == 1, 2, 1)                      # Endpoint ID for endpoint not being used for look positioning
    nonsyncEPType <- DesignParam$EndpointType[[nonsyncEPID]]                    # Endpoint type of the endpoint not being used for look positioning
    
    # Look info was provided so use it
    nQtyOfLooks         <- LookInfo$NumLooks
    nLookIndex          <- LookInfo$CurrLookIndex
    
    # CumTargets will be planned cumulative events/completers for the Endpoint used for the current look positioning.
    if(nLookIndex <= LookInfo$NumEndpointLooks[syncEPID]) 
    {
      if(syncEPType == 2 )
      {
        CumTargets    <- LookInfo$CumEvents[[DesignParam$EndpointName[syncEPID]]]
      }
      else
      {
        CumTargets    <- LookInfo$CumCompleters[[DesignParam$EndpointName[syncEPID]]]
      }
    } 
    else
    {
      if(nonsyncEPType == 2 )
      {
        CumTargets    <- LookInfo$CumEvents[[DesignParam$EndpointName[nonsyncEPID]]]
      }
      else
      {
        CumTargets    <- LookInfo$CumCompleters[[DesignParam$EndpointName[nonsyncEPID]]]
      }
    }
    
    nQtyOfTargets <- CumTargets[nLookIndex]
    
    EPIDforSlicingData <- ifelse(nLookIndex <= LookInfo$NumEndpointLooks[syncEPID] , syncEPID, nonsyncEPID) 
    if(EPIDforSlicingData == 1) 
    {
      SimDataAnlys <- SimData[order(SimData$ClndrRespTime, SimData$CensorIndOrg), ]
      idxAnlys <- which(cumsum(SimDataAnlys$CensorIndOrg) >= nQtyOfTargets)
      AnalysisTime <- ifelse(length(idxAnlys) > 0, 
                             SimDataAnlys$ClndrRespTime[min(idxAnlys)], 
                             SimDataAnlys$ClndrRespTime[DesignParam$SampleSize])
    }
    else 
    {
      SimDataAnlys <- SimData[order(SimData$ClndrRespTime2, SimData$CensorIndOrg2), ]
      idxAnlys <- which(cumsum(SimDataAnlys$CensorIndOrg2) >= nQtyOfTargets)
      AnalysisTime <- ifelse(length(idxAnlys) > 0, 
                             SimDataAnlys$ClndrRespTime2[min(idxAnlys)], 
                             SimDataAnlys$ClndrRespTime2[DesignParam$SampleSize]) 
    }
  }
  
  else                        #FSD design
  {   
    nQtyOfLooks  <- 1
    nLookIndex   <- 1
    
    
    # nQtyOfTargets will be planned events/completers for the Endpoint on which end of the trial is defined.
    if(DesignParam$PlanEndTrial == 2 || DesignParam$PlanEndTrial == 1)  #Full info on Endpoint 1 or Both Endpoints
    {
      nQtyOfTargets <- ifelse( DesignParam$EndpointType[1] == 1,  
                               DesignParam$MaxCompleters[[DesignParam$EndpointName[1]]],
                               DesignParam$MaxEvents[[DesignParam$EndpointName[1]]] )
      SimDataEP1 <- SimData[order(SimData$ClndrRespTime, SimData$CensorIndOrg), ]
      idxEP1 <- which(cumsum(SimDataEP1$CensorIndOrg) >= nQtyOfTargets)
      AnalysisTimeEP1 <- ifelse(length(idxEP1) > 0, 
                                SimDataEP1$ClndrRespTime[min(idxEP1)], 
                                SimDataEP1$ClndrRespTime[DesignParam$SampleSize])
      
    }
    if(DesignParam$PlanEndTrial == 3 || DesignParam$PlanEndTrial == 1)  #Full info on Endpoint 2 or Both Endpoints
    {
      nQtyOfTargets <- ifelse( DesignParam$EndpointType[2] == 1,  
                               DesignParam$MaxCompleters[[DesignParam$EndpointName[2]]],
                               DesignParam$MaxEvents[[DesignParam$EndpointName[2]]] )
      SimDataEP2 <- SimData[order(SimData$ClndrRespTime2, SimData$CensorIndOrg2), ]
      idxEP2 <- which(cumsum(SimDataEP2$CensorIndOrg2) >= nQtyOfTargets)
      AnalysisTimeEP2 <- ifelse(length(idxEP2) > 0, 
                                SimDataEP2$ClndrRespTime2[min(idxEP2)], 
                                SimDataEP2$ClndrRespTime2[DesignParam$SampleSize])
      
    }    
    
    AnalysisTime <- ifelse( DesignParam$PlanEndTrial == 1, max(AnalysisTimeEP1, AnalysisTimeEP2), 
                            ifelse(DesignParam$PlanEndTrial == 2, AnalysisTimeEP1, AnalysisTimeEP2) )
  }
  return(AnalysisTime)
}