########################################################################################################################
#  Last Modified Date: 22/09/2025
#  
#' @name AnalyzeDEPUsingModWtLogRank
#' @author Pradip Maske
#' @title Compute the moderately weighted log rank test statistic.
#'
#' @description Compute moderately weighted log rank test statistic given simulation data.
#'
#' @param SimData Data frame with subject data generated in current simulation with one row per patient.
#'        It will have headers indicating the names of the columns. These names will be same as those used in
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime,
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of
#'        this data frame. For analysis the most relevant variables are:
#'          SimData$ArrivalTime :   A numeric value with the time the patient arrived in the trial
#'          SimData$TreatmentID :   An integer value where 0 indicates control treatment and 1 experimental treatment.
#'          SimData$ResponseX   :   Numeric value for the survival time or time-to-event for the patient on Endpoint X
#' @param DesignParam Input Parameters which user may need to compute test statistic and perform test.
#'                    User should access the variables using names, for example, DesignParam$Alpha, and not order.
#'                    For details of this list please see below.
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic
#'                 and perform test. User should access the variables using names,
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are:
#'                   LookInfo$NumLooks      :   An integer value with the number of looks in the study
#'                   LookInfo$CurrLookIndex :   An integer value with the current index look, starting from 1
#'                   LookInfo$InfoFrac      :   A numeric vector containing information fraction
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list.
#'                  User should access the variables using names, for example UserParam$Var1 and not order.
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{TestStat}{Required value. Test statistic on Z-scale.}
#'                  \item{ErrorCode}{Optional integer value \describe{
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }}
#'                  \item{HR}{Required numeric value - Hazard Ratio,
#'                            Only applicable for time-to-event data.}
#'             }
#'
#' @note Helpful Hints:
#'       There is often info that East sends to R that are not shown in a given example. It can be very helpful to save the input
#'       objects and then load them into your R session and inspect them. This can be done with the following R code in your function.
#'
#'       saveRDS(SimData,     "SimData.Rds")
#'       saveRDS(DesignParam, "DesignParam.Rds")
#'       saveRDS(LookInfo,    "LookInfo.Rds")
#'
#'       The above code will save each of the input objects to a file so they may be examined within R.
#' @note The current code assumes there are no dropouts. Modify the code accordingly for dropout case.
########################################################################################################################

AnalyzeDEPUsingModWtLogRank <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL) 
{
    require(survival)
    
    # Finding the endpoint ID and name of the endpoint to be analysed.
    EPID    <- ifelse(is.nan(DesignParam$TestStat$`Endpoint 1`), 1, 2)
    EPName  <- DesignParam$EndpointName[EPID] 

    bGSD <- ifelse(is.null(LookInfo), FALSE, TRUE)                              # Is the trial using Group sequential Design?
    syncEPID <- ifelse(bGSD, LookInfo$SyncInterim, DesignParam$PlanEndTrial)    # Endpoint ID to be used for look positioning
    syncEPType <- DesignParam$EndpointType[[syncEPID]]                          # Endpoint type of the endpoint used for look positioning
    
    if(bGSD)               # Group Sequential Design   
    {
        nQtyOfLooks  <- LookInfo$NumLooks
        nLookIndex   <- LookInfo$CurrLookIndex
        # CumTargets will be planned cumulative events/completers for the Endpoint used for the current look positioning.
        if(syncEPType == 2 ) 
        {
            CumTargets    <- LookInfo$InputInfoFrac[[syncEPID]] * DesignParam$MaxEvents[[syncEPID]]
        }
        else 
        {
            CumTargets    <- LookInfo$InputInfoFrac[[syncEPID]] * DesignParam$MaxCompleters[[syncEPID]]
        }
        nQtyOfTargets <- CumTargets[nLookIndex]
    } 
    else                    # Fixed Sample Design
    {
        nQtyOfLooks  <- 1
        nLookIndex   <- 1
        # nQtyOfTargets will be planned events/completers for the Endpoint on which end of the trial is defined.
        if(DesignParam$EndpointType[[syncEPID]] == 2) 
        {
            nQtyOfTargets <- DesignParam$MaxEvents[[syncEPID]]
        }
        else 
        {
            nQtyOfTargets <- DesignParam$MaxCompleters[[syncEPID]]
        }
    }
    
    SimData$TimeOfEvent <- SimData$ArrivalTime + SimData[[paste0("Response", EPID)]]
    
    # Compute the time of analysis
    if(bGSD)  
    {
        # Calendar time in the trial when patient events are observed on look positioning Endpoint.
        SimData$CalTime     <- SimData$ArrivalTime + SimData[[paste0("Response", syncEPID)]]
    }
    else
    {
        # Calendar time in the trial when patient events are observed on Endpoint on which end of the trial is defined.
        if(DesignParam$EndpointType[[syncEPID]] == 2) 
        {
            SimData$CalTime     <- SimData$ArrivalTime + SimData[[paste0("Response", syncEPID)]]
        }
        else 
        {
            SimData$CalTime     <- SimData$ArrivalTime + DesignParam$FollowUpDur[[syncEPID]]
        }
    }
    SimData         <- SimData[order(SimData$CalTime), ]
    dTimeOfAnalysis <- SimData[nQtyOfTargets, ]$CalTime
    
    # Compute the Observed Time variable for the analysis
    SimData              <- SimData[SimData$ArrivalTime <= dTimeOfAnalysis, ]  # Exclude non-enrolled patients
    SimData$Event        <- ifelse(SimData$TimeOfEvent > dTimeOfAnalysis, 0, 1)
    SimData$ObservedTime <- ifelse(SimData$TimeOfEvent > dTimeOfAnalysis,
                                   dTimeOfAnalysis - SimData$ArrivalTime,
                                   SimData$TimeOfEvent - SimData$ArrivalTime)
    
    # Order the data by observed time
    SimData <- SimData[order(SimData$ObservedTime), ]
    
    # Compute Observed HR
    coxModel <- coxph(Surv(ObservedTime, Event) ~ TreatmentID, data = SimData)
    dTrueHR  <- exp(coxModel$coefficients)
    
    SimData$EventOnTreatment <- ifelse(SimData$TreatmentID == 1, SimData$Event, 0)
    SimData$EventOnControl   <- ifelse(SimData$TreatmentID == 0, SimData$Event, 0)
    
    # Subjects at risk at baseline
    nSubjectsAtRiskTreatment <- nrow(SimData[SimData$TreatmentID == 1, ])
    nSubjectsAtRiskControl   <- nrow(SimData[SimData$TreatmentID == 0, ])
    
    # Initialize numerator and denominator
    dNum <- 0
    dDen <- 0
    
    # Iterate over subjects
    for (nSubject in 1:nrow(SimData)) 
    {
        # Non-event: update risk set
        if (SimData$Event[nSubject] == 0) 
        {
            if (SimData$TreatmentID[nSubject] == 1) 
            {
                nSubjectsAtRiskTreatment <- nSubjectsAtRiskTreatment - 1
            }
            if (SimData$TreatmentID[nSubject] == 0) 
            {
                nSubjectsAtRiskControl <- nSubjectsAtRiskControl - 1
            }
        }
        
        # Event: update dNum and dDen
        if (SimData$Event[nSubject] == 1) 
        {
            nEventsOnTreatment <- SimData$EventOnTreatment[nSubject]
            nEventsOnControl   <- SimData$EventOnControl[nSubject]
            nEvents            <- nEventsOnTreatment + nEventsOnControl
            nSubjectsAtRisk    <- nSubjectsAtRiskTreatment + nSubjectsAtRiskControl
            
            weight <- sqrt(nSubjectsAtRisk)  # Moderately weighted log-rank test
            
            dNum <- dNum + weight * (nEventsOnTreatment - nSubjectsAtRiskTreatment * nEvents / nSubjectsAtRisk)
            
            if (nSubjectsAtRisk != 1) 
            {
                dDen <- dDen + weight^2 * (
                    nSubjectsAtRiskTreatment * nSubjectsAtRiskControl *
                        (nSubjectsAtRisk - nEvents) * nEvents /
                        ((nSubjectsAtRisk - 1) * nSubjectsAtRisk^2)
                )
            }
            
            # Update risk set for next iteration
            nSubjectsAtRiskTreatment <- nSubjectsAtRiskTreatment - nEventsOnTreatment
            nSubjectsAtRiskControl   <- nSubjectsAtRiskControl - nEventsOnControl
        }
    }
    
    # Compute test statistic
    dTS   <- dNum / sqrt(dDen)
    Error <- 0
    
    return(list(
        TestStat  = as.double(dTS),
        HR        = as.double(dTrueHR),
        ErrorCode = as.integer(Error)
    ))
}