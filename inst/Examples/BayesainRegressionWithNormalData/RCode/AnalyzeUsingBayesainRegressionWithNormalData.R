#' @name RunAnalysisUsingBayesianRegression
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{ArrivalTime}{ A numeric value with the time the patient arrived in the trial}
#'          \item{TreatmentID}{An integer value where 0 indicates control treatment and 1 experimental treatment.}
#'          \item{Response}{A numeric value indicating the response. }
#'          \item{CensorIndOrg}{An integer value indicating whether the subject was censored or not. }
#'        }
#' @param DesignParam R List which consists of Design and Simulation Parameters which user
#'      may need to compute test statistic and perform test. User should access the variables
#'      using names for eg. DesignParam$Alphae and not order.  Them items are as follows:
#'      \describe{
#'          \item{SampleSize}{Sample size of the trial}
#'          \item{Alpha}{Type I Error}
#'          \item{TestType}{Values are One side: 0; Two Sided: 1, Two Sided, Asymmetric: 2 }
#'          \item{TailType}{Values are Left Tailed: 0, Right Tailed: 1}
#'          \item{LowerAlpha}{Two Sided Asymmetric Tests }
#'          \item{UpperAlpha}{Two Sided Asymmetric Tests }
#'          \item{MaxCompleters}{Maximum Number of Completers}
#'          \item{FollowUpType}{For survival tests, Follow Up Type.  Possible values are: Until End ofS Study: 0, For fixed period: 1}
#'          \item{AllocInfo}{Vector of the ratios of the treatment group sample sizes to control group sample size. }
#'          \item{CriticalPoint}{Critical Value for a fixed sample design. }
#'          \item{FollowUpType}{Follow up type. Integer value with the following meaning:\describe{
#'                                    \item{FollowUpType = 0}{Until End of the Study}
#'                                    \item{FollowUpType = 1}{For Fixed Period}
#'                                    }
#'                                    }
#'          \item{FollowUpDur}{Follow up duration}
#'          \item{TrtEffNull}{Treatment Effect under Null on natural scale. Applicable for Non-inferiority trials. }
#'      
#'      }
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                 \describe{
#'                      \item{NumLooks}{An integer value with the number of looks in the study}
#'                      \item{CurrLookIndex}{An integer value with the current index look, starting from 1}
#'                      \item{CumCompleters}{Cumulative number of completer for all non time-to-event studies.}
#'                      \item{InfoFrac}{Information fraction}
#'                      \item{CumAlpha}{cumulative alpha spent, one sided tests}
#'                      \item{EffBdryScale}{Efficacy boundary scale.  Possible vaues are: Z Scale: 0, p-Value Scale: 1}
#'                      \item{EffBdry}{Vector of efficacy bondaries, one sided tests}
#'                      \item{EffBdryUpper}{Vector of upper efficacy bondaries, two sided tests}
#'                      \item{EffBdryLower}{Vector of lower efficacy boundary, two sided tests}
#'                      \item{FutBdryScale}{Futility boundary scale. Possible value are:  Z Scale: 0, p-Value Scale: 1, Delta Scale: 2, Conditional Power Scale: 3}
#'                      \item{FutBdry}{Vector of futility bondaries, one sided tests.}
#'                      \item{FutBdryUpper}{Vector of upper futility boundaries, two sided tests}
#'                      \item{FutBdryLower}{Vector of lower futility boundaries, two sided tests}
#'                 }
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @param SamplingMethod \describe{if(nSamplingMethod == 1) then JAGS else Stan}                 
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Optional value. Integer Value with the following meaning:
#'                                  \describe{
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is  crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    \item{Decision = 4}{when the Equivalence Boundary Crossed}
#'                                    } 
#'                                    }
#'                  \item{TestStat}{Numeric value. Required if Decision is not returned}
#'                  \item{Delta}{Numeric value. Required if Decision is not returned AND Futility Boundary scale is either Delta or CP. }
#'                  \item{CtrlCompleters}{Integer value. Required if Decision is not returned and Futility Boundary scale is CP. }
#'                  \item{TrmtCompleters }{Integer value. Required if Decision is not returned and Futility Boundary scale is CP. }
#'                  \item{CtrlPi}{Numeric value. Required if Decision is not returned and Futility Boundary scale is CP. }
#'                  \item{ErrorCode}{Optional integer value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                      }
RunAnalysisUsingBayesianRegression <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    #library(CyneRgy)
   
    
    Error 	    <- 0
    nDecision 	<- 0
    
    if(  !is.null( LookInfo )  )
    {
        # Group sequential design
        nLookIndex           <- LookInfo$CurrLookIndex
        nQtyOfLooks          <- LookInfo$NumLooks
        nQtyOfEvents         <- LookInfo$CumEvents[ nLookIndex ]
        nQtyOfPatsInAnalysis <- LookInfo$CumCompleters[ nLookIndex ]
    }
    else
    {
        # Fixed Design
        nLookIndex           <- 1
        nQtyOfLooks          <- 1
        nQtyOfEvents         <- DesignParam$MaxCompleters
        nQtyOfPatsInAnalysis <- nrow( SimData )
    }
    
    # Get the subset of data included at this analysis
   SimData <- SimData[ 1:nQtyOfPatsInAnalysis,  ]
    
    if( is.null( UserParam ) )
    {
        # By default - Sample using JAGS and  Assuming:
        # non-informative priors
        # Stop for futility at the Interim Analysis if Prob( E > C ) < 0.1
        # At the Final Analysis select E if Prob( E > C ) > 0.95
        UserParam <- list( dBeta0PriorMean = 0,
                           dBeta0PriorSD   = 10,
                           dBeta1PriorMean = 0,
                           dBeta1PriorSD   = 10,
                           dBeta2PriorMean = 0,
                           dBeta2PriorSD   = 100, 
                           dBeta3PriorMean = 0,
                           dBeta3PriorSD   = 100,
                           dPL             = 0.1, 
                           dPU1            = 0.99,
                           dPU2            = 0.95,
                           nSamplingMethod = 1) 
    }
    
    lData <- list( nQtyPats = nrow( SimData ), vY = SimData$Response, vGoodPrognosis = SimData$GoodPrognosis, vTreatment = SimData$TreatmentID,
                   dBeta0PriorMean = UserParam$dBeta0PriorMean, dBeta0PriorSD = UserParam$dBeta0PriorSD,
                   dBeta1PriorMean = UserParam$dBeta1PriorMean, dBeta1PriorSD = UserParam$dBeta1PriorSD,
                   dBeta2PriorMean = UserParam$dBeta2PriorMean, dBeta2PriorSD = UserParam$dBeta2PriorSD,
                   dBeta3PriorMean = UserParam$dBeta3PriorMean, dBeta3PriorSD = UserParam$dBeta3PriorSD )

    if(UserParam$nSamplingMethod == 1) {
        lPostSample <- SamplePosterior( lData, UserParam, 1000, 0 ) #Sampling using JAGS    
    } else {
        lPostSample <- SamplePosterior_stan(lData, UserParam, 1000, 0) #Sampling using Stan
    }
    
    if( nLookIndex < nQtyOfLooks )  # Interim Analysis 
    {
        strDecision <- "Continue"
        if( lPostSample$dPrGrtMAV >  UserParam$dPU1   )
            strDecision <- "Efficacy"
        else if( lPostSample$dPrGrtMAV < UserParam$dPL  )
            strDecision <- "Futility"
    }
    else # Final Analysis
    {
        if( lPostSample$dPrGrtMAV >= UserParam$dPU2  )
            strDecision <- "Efficacy"
        else 
            strDecision <- "Futility" 
    }
    
    nDecision <- GetDecision( strDecision, DesignParam, LookInfo )
    
    # Write the actual code here.
    # Compute test statistic value and store the decision
    # value (appropriate code) in retval
    # Use appropriate error handling and modify the
    # Error appropriately
    
    return(list(TestStat = as.double(0), Decision = as.integer(nDecision), ErrorCode = as.integer(Error)))
}

SamplePosterior<- function( lData, UserParam, nQtySamplesPerChain , dDelta )
{
    
    library( R2jags )
    
    lInits           <- list( InitsNormalModel( UserParam ), InitsNormalModel( UserParam ), InitsNormalModel( UserParam ))  # Going to run 3 chains
    strModelFile     <- paste0( "BayesianModel1.txt" )
    
    strModel <- "model
                {
                    # N observations
                    for( i in 1:nQtyPats )
                    {
                
                        vY[i] ~ dnorm( vMean[ i ], 1 )
                        vMean[ i ] 	<- dBeta0 + vTreatment[ i ]*dBeta1 + vGoodPrognosis[ i ] * dBeta2 +  vTreatment[ i ] * vGoodPrognosis[ i ] * dBeta3
                    }
                
                
                    # Priors
                    dBeta0   ~ dnorm( dBeta0PriorMean, 1/( dBeta0PriorSD*dBeta0PriorSD ) )
                    dBeta1   ~ dnorm( dBeta1PriorMean, 1/( dBeta1PriorSD*dBeta1PriorSD )  )
                
                    dBeta2 ~ dnorm( dBeta2PriorMean, 1/( dBeta2PriorSD*dBeta2PriorSD )  )
                    dBeta3 ~ dnorm( dBeta3PriorMean, 1/( dBeta3PriorSD*dBeta3PriorSD )  )
                }"
    
    
    model            <- jags.model( textConnection( strModel ), lData, lInits, n.chains=3, quiet = TRUE  )
    

    update( model, 1000, progress.bar = "none", quiet = TRUE)
    vTrace          <- c("dBeta1" )
    mSamps          <- coda.samples( model, vTrace , n.iter=nQtySamplesPerChain, quiet = TRUE, progress.bar = "none" )
    mSamps          <- rbind(mSamps[,][[1]],mSamps[,][[2]],mSamps[,][[3]])

    vBeta1          <- mSamps[ , 1 ]


    dPrGrtMAV       <- mean( ifelse( vBeta1 > dDelta, 1, 0) )
    

    return( list( dPrGrtMAV = dPrGrtMAV ))

}


SamplePosterior_stan<- function(lData, UserParam, nQtySamplesPerChain , dDelta)
{
    library(StanHeaders)
    library(rstan)
    
    #Please ensure there is no space after("data) and before(}") double quotes
    #Stan Model
    strModel <- "data {
                        int<lower=1> nQtyPats;
                        vector[nQtyPats] vY;
                        vector[nQtyPats] vGoodPrognosis;
                        vector[nQtyPats] vTreatment;
  
                        real dBeta0PriorMean;
                        real<lower=0> dBeta0PriorSD;
                        real dBeta1PriorMean;
                        real<lower=0> dBeta1PriorSD;
                        real dBeta2PriorMean;
                        real<lower=0> dBeta2PriorSD;
                        real dBeta3PriorMean;
                        real<lower=0> dBeta3PriorSD;
                      }

                 parameters {
                        real dBeta0;
                        real dBeta1;
                        real dBeta2;
                        real dBeta3;
                      }

                 model {
                        dBeta0 ~ normal(dBeta0PriorMean, (dBeta0PriorSD*dBeta0PriorSD));
                        dBeta1 ~ normal(dBeta1PriorMean, (dBeta1PriorSD*dBeta1PriorSD));
                        dBeta2 ~ normal(dBeta2PriorMean, (dBeta2PriorSD*dBeta2PriorSD));
                        dBeta3 ~ normal(dBeta3PriorMean, (dBeta3PriorSD*dBeta3PriorSD));    
    
                        vector[nQtyPats] vMean;
  
                        for(i in 1:nQtyPats) 
                        {
                            vMean[i] <- dBeta0 + (vTreatment[i] * dBeta1) + (vGoodPrognosis[i] * dBeta2) + (vTreatment[i] * vGoodPrognosis[i] * dBeta3);
                            vY[i] ~ normal(vMean[i], 1);
                        }
                 }"
    
    #Compiling and Construct the Stan model  
    model <- stan_model(model_code = strModel)
    #Initialize the parameters for each chain, Going to run 3 chains
    lInits <- list(InitsNormalModel(UserParam), InitsNormalModel(UserParam), InitsNormalModel(UserParam))
    #Draw samples from the Stan Model
    #We need to add 1000 to iter since iter (burnin + steady) includes warmp (burnin) simulations 
    mSamps <- sampling(object=model, data=lData, init=lInits, chains=3, iter=nQtySamplesPerChain+1000, warmup=1000, refresh=0, cores=1)
    
    #Extract the samples
    mSamps <- extract(mSamps)
    vBeta1 <- mSamps$dBeta1
    dPrGrtMAV <- mean(ifelse(vBeta1 > dDelta, 1, 0))
    
    return(list(dPrGrtMAV = dPrGrtMAV))
}


InitsNormalModel <- function( UserParam )
{

    dBeta0   <-  rnorm( 1, UserParam$dBeta0PriorMean, UserParam$dBeta0PriorSD )
    dBeta1   <-  rnorm( 1, UserParam$dBeta1PriorMean, UserParam$dBeta1PriorSD )
    dBeta2   <-  rnorm( 1, UserParam$dBeta2PriorMean, UserParam$dBeta2PriorSD )
    dBeta3   <-  rnorm( 1, UserParam$dBeta3PriorMean, UserParam$dBeta3PriorSD )


    return( list( dBeta0 = dBeta0, dBeta1 = dBeta1, dBeta2 = dBeta2, dBeta3 = dBeta3 ) )
}

#' @name GetDecision
#' @title GetDecision
#' @description { Description: This function takes a string for the desired decision, design and look info and return the correct decision value.  
#' If LookInfo is not Null then looking at LookInfo$RejType can help determine the design type
#'   LookInfo$RejType Codes:
#'     Efficacy Only:
#'       1 Sided Efficacy Upper = 0
#'       1 Sided Efficacy Lower = 2
#'     
#'     Futility Only:
#'       1 Sided Futility Upper = 1
#'       1 Sided Futility Lower = 3
#'     
#'     Efficacy Futility:
#'       1 Sided Efficacy Upper Futility Lower = 4 
#'       1 Sided Efficacy Lower Futility Upper = 5
#'     
#'     Not in East Horizon Explore Yet:
#'       2 Sided Efficacy Only = 6
#'       2 Sided Futility Only = 7
#'       2 Sided Efficacy Futility = 8
#'       Equivalence = 9
#'
#'   Then using DesignParam$TailType
#'       0: Left Tailed
#'       1: Right Tailed
#'
#' 
#' 
#' }
#' @param strDecision is a  string with either "Efficacy", "Futility" or "Continue"
#' @param DesignParam This is the DesignParam sent from East Horizon Explore to the R integration for analysis.
#' @param LookInfo The LookInfo parameter sent from East Horizon Explore to the R integration for analysis.
#' @export
GetDecision <- function(  strDecision, DesignParam, LookInfo )
{
    nReturnDecision <- -1   # This is an error 
    strDesignType   <- NA
    strDirection    <- ""
    
    # Step 1 - Determine the  direction
    if( DesignParam$TailType == 0 )
    {
        strDirection <- "Left"
    }
    else if(  DesignParam$TailType == 1 )
    {
        strDirection <- "Right"
    }
    
    # Step 2 - determine the design type so we know what decision to return ####
    
    if( is.null( LookInfo ) )
    {
        # No LookInfo so this is a fixed design --> EfficacyOnly
        strDesignType    <- "EfficacyOnly"
        bInterimAnalysis <- FALSE
        
    }
    else if( LookInfo$RejType == 1 | LookInfo$RejType == 3 )
    {
        # There is a futility boundary but no efficacy boundary
        strDesignType    <- "FutilityOnly"
        bInterimAnalysis <- LookInfo$CurrLookIndex < LookInfo$NumLooks 
    }
    else if( LookInfo$RejType == 0 | LookInfo$RejType == 2 )
    {
        # There is an efficacy boundary but no futility boundary
        strDesignType    <- "EfficacyOnly"
        bInterimAnalysis <- LookInfo$CurrLookIndex < LookInfo$NumLooks 
    }
    else if( LookInfo$RejType == 4 | LookInfo$RejType == 5 )
    {
        # There is an efficacy boundary and futility boundary
        strDesignType    <- "EfficacyFutility"
        bInterimAnalysis <- LookInfo$CurrLookIndex < LookInfo$NumLooks 
    }
    
    
    # Can we use the DesignParam and LookInfo to define the design type and IA/FA?  -  Assuming we can suppose strDesignType = "FutilityOnly", "EfficacyOnly" or "EfficacyFutiity"
    
    if( strDirection == "Right" )
    {
        if( strDesignType == "FutilityOnly" )
        {
            if( bInterimAnalysis )
            {
                if( strDecision == "Futility" )
                { 
                    nReturnDecision <- 3
                }
                else if( strDecision == "Continue" )
                {
                    nReturnDecision <- 0
                }
                
            }
            else # It is a futility only design at the final analysis
            {
                if( strDecision == "Futility" )
                { 
                    nReturnDecision <- 3
                }
                else if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 0
                }
                
            }
            
        }
        else if( strDesignType == "EfficacyOnly" )
        {
            if( bInterimAnalysis )
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 2
                }
                else if(strDecision == "Continue"  )
                {
                    nReturnDecision <- 0
                }
            }
            else
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 2
                }
                else if(strDecision == "Futility"  )
                {
                    nReturnDecision <- 0
                }
                
            }
        }    
        else if( strDesignType == "EfficacyFutility" )
        {
            
            if( bInterimAnalysis )
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 2
                }
                else if(strDecision == "Futility"  )
                {
                    nReturnDecision <- 3
                }
                else if(strDecision == "Continue"  )
                {
                    nReturnDecision <- 0
                }
            }
            else
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 2
                }
                else if(strDecision == "Futility"  )
                {
                    nReturnDecision <- 3
                }
                
            }
        }
    }
    else if( strDirection == "Left" )
    {
        
        if( strDesignType == "FutilityOnly" )
        {
            if( bInterimAnalysis )
            {
                if( strDecision == "Futility" )
                { 
                    nReturnDecision <- 3
                }
                else if( strDecision == "Continue" )
                {
                    nReturnDecision <- 0
                }
                
            }
            else # It is a futility only design at the final analysis
            {
                if( strDecision == "Futility" )
                { 
                    nReturnDecision <- 3
                }
                else if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 0
                }
                
            }
            
        }
        else if( strDesignType == "EfficacyOnly" )
        {
            if( bInterimAnalysis )
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 1
                }
                else if(strDecision == "Continue"  )
                {
                    nReturnDecision <- 0
                }
            }
            else
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 1
                }
                else if(strDecision == "Futility"  )
                {
                    nReturnDecision <- 0
                }
                
            }
        }    
        else if( strDesignType == "EfficacyFutility" )
        {
            
            if( bInterimAnalysis )
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 1
                }
                else if(strDecision == "Futility"  )
                {
                    nReturnDecision <- 3
                }
                else if(strDecision == "Continue"  )
                {
                    nReturnDecision <- 0
                }
            }
            else
            {
                if( strDecision == "Efficacy" )
                {
                    nReturnDecision <- 1
                }
                else if(strDecision == "Futility"  )
                {
                    nReturnDecision <- 3
                }
                
            }
        }
        
    }
    
    
    return( as.integer(nReturnDecision) )
}