#  Last Modified Date: {{CREATION_DATE}}
#' @name {{FUNCTION_NAME}}
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{ArrivalTime}{A numeric value with the time the patient arrived in the trial}
#'          \item{TreatmentID}{An integer value specifying the index of arms to which subjects are allocated (one arm index per subject). Index for control is 0}
#'          \item{SurvivalTime}{Numeric value for the survival time or time-to-event for the patient, note this is not the time in the trial
#'                               that the patient experiences the event.}
#'          \item{DropOutTime}{Numeric value for the dropout time for the patient in a time to event trial.}
#'        }
#' @param DesignParam R List which consists of Design and Simulation Parameters which user
#'      may need to compute test statistic and perform test. User should access the variables
#'      using names for e.g., DesignParam$Alpha and not order. Them items are as follows:
#'      \describe{
#'          \item{SampleSize}{Integer. Sample size of the trial}
#'          \item{Alpha}{Numeric. Type I Error}
#'          \item{TrialType}{Integer. Type of the Trial. Values are Superiority: 0}
#'          \item{TestType}{Integer. Values are One side: 0}
#'          \item{TailType}{Integer. Values are Left Tailed: 0, Right Tailed: 1}
#'          \item{InitialAllocInfo}{Vector of the ratios of the treatment group sample sizes to control group sample size.}
#'          \item{TestID}{Integer. Test ID. Values are Difference of Proportions: 303}
#'          \item{MultAdjMethod}{Integer. Multiple Comparison Procedure. Values are Bonferroni: 0, Weighted Bonferroni: 2, Hochberg's Step Up: 4, Fixed Sequence: 6, Fallback: 7}
#'          \item{NumTreatments}{Integer. Number of Treatment arms}
#'          \item{AlphaProp}{Vector of Proportions of Alpha for each treatment arm}
#'          \item{TestSeq}{Vector of integer Test Sequence for each comparison which corresponds to each treatment arm.}
#'          \item{CriticalPoint}{Numeric. Critical Value for a fixed sample design.}
#'          \item{IsArmPresent}{Vector of integer flags indicating whether an arm is still present in the trial or was dropped in the interim. Length = number of arms. Values are Dropped in the interim: 0, Still present in the trial: 1}
#'          \item{UpdatedAllocInfo}{Vector of ratios of the treatment group sample sizes to control group sample size which may have been updated during treatment selection. Length = number of arms. First value is control.}
#'          \item{MaxEvents}{Integer. Maximum Events.}
#'          \item{FollowUpType}{Integer. Follow up Type. Values are Until end of the study: 0, For fixed period: 1}
#'          \item{FollowUpDur}{Numeric. Follow up duration.}
#'      
#'      }
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                 \describe{
#'                      \item{NumLooks}{An integer value with the number of looks in the study.}
#'                      \item{CurrLookIndex}{An integer value with the current index look, starting from 1.}
#'                      \item{CumEvents}{Vector of Cumulative events. Length = Number of looks.}
#'                      \item{InfoFrac}{Vector of numeric Information fraction. Length = Number of looks.}
#'                      \item{CumAlpha}{Vector of numeric Cumulative alpha spent, one sided tests. Length = Number of looks.}
#'                      \item{EffBdryScale}{Integer. Efficacy boundary scale. Possible vaues are: Z Scale: 0}
#'                      \item{EffBdry}{Vector of numeric efficacy bondaries, one sided tests. Length = Number of looks.}
#'                      \item{FutBdryScale}{Integer. Futility boundary scale. Possible value are: HR Scale: 2}
#'                      \item{FutBdry}{Vector of numeric futility bondaries, one sided tests. Length = Number of looks.}
#'                      \item{RejType}{Integer. Rejection Type. Values are: 1 Sided Efficacy Upper: 0, 1 Sided Futility Upper: 1, 1 Sided Efficacy Lower: 2, 1 Sided Futility Lower: 3, 1 Sided Efficacy Upper Futility Lower: 4, 1 Sided Efficacy Lower Futility Upper: 5}
#'                 }
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Vector of Integers or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if Decision is returned. Values have the following meaning:
#'                                  \describe{
#'                                    \item{Decision = NA}{When the arm is dropped in a previous look}
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    }
#'                                    }
#'                  \item{AdjPVal}{p-Value adjusted for MCP adjustment. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if AdjPVal is returned and if there is no Futility Boundary.}
#'                  \item{RawPVal}{p-Value computed from test statistics. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if RawPVal is returned and if there is no Futility Boundary.}
#'                  \item{TestStat}{Value of appropriate Test Statistic on Wald ﴾Z﴿ scale regardless of the Efficacy or Futility Boundary Scale for each Treatment Arm. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. All other outputs become optional if TestStat is returned and if there is no Futility Boundary.}
#'                  \item{HR}{Estimate of Hazard Ratio for each Treatment Arm. Vector of Numerics or 'NA's having length the same as number of treatment arms. Arms dropped in a previous look should have value 'NA'. Optional value. Required if Decision is not returned AND Futility Boundary scale is HR}
#'                  \item{ErrorCode}{Integer. Optional value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Nonfatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                      }
{{FUNCTION_NAME}} <- function( SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
    nError 	         <- 0
    
    # If LookInfo is Null, then this is a fixed design and we use the DesignParam$MaxEvents
    # Retrieve necessary information from the R objects. You may not need all the variables
    if(  !is.null( LookInfo )  )
    {
        nQtyOfLooks          <- LookInfo$NumLooks
        nLookIndex           <- LookInfo$CurrLookIndex
        nQtyOfPatsInAnalysis <- LookInfo$CumEvents[ nLookIndex ]
        RejType              <- LookInfo$RejType
        TailType             <- DesignParam$TailType
    }
    else
    {
        nQtyOfLooks          <- 1
        nLookIndex           <- 1
        nQtyOfPatsInAnalysis <- DesignParam$MaxEvents
        TailType             <- DesignParam$TailType
    }
    
    # User can create the analysis script in one of the following ways: ####
    # Option 1: Script returns Decision ####

    bIAEfficayCheck  <- TRUE
    bIAFutilityCheck <- FALSE
    bFAEfficacyCheck <- TRUE
    
    # Setup look decision logic
    # Generate decision using GetDecisionString and GetDecision helpers
    strDecision <- CyneRgy::GetDecisionString( LookInfo, nLookIndex, nQtyOfLooks, 
                                               bIAEfficacyCondition = bIAEfficayCheck,
                                               bIAFutilityCondition = bIAFutilityCheck,
                                               bFAEfficacyCondition = bFAEfficacyCheck)
    
    nDecision <- CyneRgy::GetDecision( strDecision, DesignParam, LookInfo )
    
    vDecision <- rep( nDecision, DesignParam$NumTreatments )
    return( list(Decision  = as.integer(vDecision), 
                 ErrorCode = as.integer(nError)) )
    
    # Option 2: Script returns adjusted p value ####
    vAdjPVal <- 0
    vHR <- 0
    # Setup adjusted p value calculation logic
    return( list(AdjPVal = vAdjPVal,
                 HR = vHR,
                 ErrorCode = as.integer(nError)) )
    
    # Option 3: Script returns raw p value
    vRawPVal <- 0
    vHR <- 0
    # Setup raw p value calculation logic
    return( list(RawPVal = vRawPVal,
                 HR = vHR,
                 ErrorCode = as.integer(nError)) )
    # Option 4: Script returns test statistic
    vTestStat <- 0
    vHR <- 0
    # Setup test statistic calculation logic
    return( list(TestStat = vTestStat,
                 HR = vHR,
                 ErrorCode = as.integer(nError)))
    
}

