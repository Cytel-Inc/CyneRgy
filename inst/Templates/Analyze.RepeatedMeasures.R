#' Last Modified Date: {{CREATION_DATE}}
#' @name {{FUNCTION_NAME}}
#' @param SimData Data frame with subject data generated in current simulation with one row per patient. 
#'        It will have headers indicating the names of the columns. These names will be same as those used in 
#'        Data Generation. User should access the variables using headers, for example, SimData$ArrivalTime, 
#'        and not order. Optional outputs generated by Data Generation will also be available as columns of 
#'        this data frame. For analysis the most relevant variables are:
#'        \describe
#'        {
#'          \item{ArrivalTime}{ A numeric value with the time the patient arrived in the trial}
#'          \item{ArrTimeVisit<VisitID>}{A numeric value with the time the patient arrived in the trial for the <VisitID>th visit.}
#'          \item{TreatmentID}{An integer value where 0 indicates control treatment and 1 experimental treatment.}
#'          \item{Response<VisitID>}{Numeric value for the response from the patient at the <VisitID>th visit. }
#'          \item{CensorInd<VisitID>}{A binary (0-1) value where 1 indicates that the patient was censored at the <VisitID>th visit.}
#'          \item{DropoutVisitID}{An integer value which indicates the ID of the visit where the patient was censored. }
#'        }
#' @param DesignParam R List which consists of Design and Simulation Parameters which user
#'      may need to compute test statistic and perform test. User should access the variables
#'      using names for eg. DesignParam$Alpha and not order.  Them items are as follows:
#'      \describe{
#'          \item{SampleSize}{Sample size of the trial}
#'          \item{Alpha}{Type I Error}
#'          \item{TestType}{Values are One side: 0; Two Sided: 1, Two Sided, Asymmetric: 2 }
#'          \item{TailType}{Values are Left Tailed: 0, Right Tailed: 1}
#'          \item{LowerAlpha}{Two Sided Asymmetric Tests }
#'          \item{UpperAlpha}{Two Sided Asymmetric Tests }
#'          \item{MaxCompleters}{Maximum Completers for a Continuous ep design}
#'          \item{ResponseLag}{Fixed Followup time between first visit and Final visit }
#'          \item{AllocInfo}{Allocation ratio on Control and Experimental arm }
#'          \item{CriticalPoint}{Z Critical value for a given Alpha}
#'          \item{NumVisit}{Integer number of visits in a Design}
#'          \item{VisitTime}{Numeric vector containing visit times}
#'          \item{VisitStatus}{Integer vector indicating the visit selection status. 0 - Visit selected for analysis. 1 - Otherwise }
#'          \item{PrimContrastCoeff}{Numeric vector containing Primary Contrast Coefficient per visit }
#'          \item{SecContrastCoeff}{Numeric vector containing Secondary Contrast Coefficient per visit }
#'          \item{DropImpt}{Integer value for Dropout imputation method. 1 indicates None, 0 indicates LOCF }
#'      }
#' @param LookInfo List Input Parameters related to multiple looks which user may need to compute test statistic 
#'                 and perform test. User should access the variables using names, 
#'                 for example LookInfo$NumLooks and not order. Other important variables in group sequential designs are: 
#'                 \describe{
#'                      \item{NumLooks}{An integer value with the number of looks in the study}
#'                      \item{CurrLookIndex}{An integer value with the current index look, starting from 1}
#'                      \item{CumCompleters}{Cumulative number of completer for all non time-to-event studies.}
#'                      \item{InfoFrac}{Information fraction}
#'                      \item{EffBdryScale}{Efficacy boundary scale.  Possible vaues are: Z Scale: 0, p-Value Scale: 1}
#'                      \item{EffBdry}{Vector of efficacy bondaries, one sided tests}
#'                      \item{EffBdryUpper}{Vector of upper efficacy bondaries, two sided tests}
#'                      \item{EffBdryLower}{Vector of lower efficacy boundary, two sided tests}
#'                      \item{FutBdryScale}{Futility boundary scale. Possible value are:  Z Scale: 0, p-Value Scale: 1, Delta Scale: 2, Conditional Power Scale: 3}
#'                      \item{FutBdry}{Vector of futility bondaries, one sided tests.}
#'                      \item{FutBdryUpper}{Vector of upper futility boundaries, two sided tests}
#'                      \item{FutBdryLower}{Vector of lower futility boundaries, two sided tests}
#'                      \item{InterimVisit}{1 based index of the visit which is driving the interims}
#'                      \item{FutContrast}{The contrast based on which futility boundaries are being computed. 0- Primary, 1-Secondary}
#'                      \item{IncludePipeline}{Flag indicating whether to include pipeline subjects in the interim or not. 0- Don't include. 1- Include}
#'                 }
#' @param UserParam User can pass custom scalar variables defined by users as a member of this list. 
#'                  User should access the variables using names, for example UserParam$Var1 and not order. 
#'                  These variables can be of the following types: Integer, Numeric, or Character
#' @return The function must return a list in the return statement of the function. The information below lists 
#'             elements of the list, if the element is required or optional and a description of the return values if needed.
#'             \describe{
#'                  \item{Decision}{Required value. Integer Value with the following meaning:
#'                                  \describe{
#'                                    \item{Decision = 0}{when No boundary, futility or efficacy is  crossed}
#'                                    \item{Decision = 1}{when the Lower Efficacy Boundary Crossed}
#'                                    \item{Decision = 2}{when the Upper Efficacy Boundary Crossed}
#'                                    \item{Decision = 3}{when the Futility Boundary Crossed}
#'                                    \item{Decision = 4}{when the Equivalence Boundary Crossed}
#'                                    } 
#'                                    }
#'                  \item{ErrorCode}{ Optional value \describe{ 
#'                                     \item{ErrorCode = 0}{No Error}
#'                                     \item{ErrorCode > 0}{Non fatal error, current simulation is aborted but the next simulations will run}
#'                                     \item{ErrorCode < 0}{Fatal error, no further simulation will be attempted}
#'                                     }
#'                                     }
#'                                     
#'                  \item{PrimDelta}{ Float value that gives estimate of Primary contrast delta, 
#'                                    Mandatory If FutBdryScale = 2 (Delta Scale) and FutContrast = 0 (Primary Contrast) 
#'                                    else optional}
#'                  
#'                  \item{SecDelta}{ Float value that gives estimate of Secondary contrast delta 
#'                                  Mandatory if FutBdryScale = 2 (Delta Scale) and FutContrast = 1 (Secondary Contrast)
#'                                  else optional}                 
#'                   
#'                   \item{TestStat}{ Float value, Mandatory If FutBdryScale = 2 (Delta Scale) and FutContrast = 0 (Primary Contrast)}                  
#'                                  { Mandatory If FutBdryScale = 2 (Delta Scale) and FutContrast = 1 (Secondary Contrast)
#'                                  else optional }
#'                      
#'                      }
#'                      
#'                      
{{FUNCTION_NAME}} <- function(SimData, DesignParam, LookInfo = NULL, UserParam = NULL )
{
     library(CyneRgy)
    
     nError           <- 0
     nDecision        <- 0
     dPrimDeltaEst    <- 0
     dSecDeltaEst     <- 0
     bIAEfficayCheck  <- TRUE
     bIAFutilityCheck <- FALSE
     bFAEfficacyCheck <- TRUE
     
     # Step 1 - If LookInfo is Null, then this is a fixed design and we use the DesignParam$MaxEvents
     if(  !is.null( LookInfo )  )
     {
         nQtyOfLooks          <- LookInfo$NumLooks
         nLookIndex           <- LookInfo$CurrLookIndex
         nQtyOfPatsInAnalysis <- LookInfo$CumCompleters[ nLookIndex ]
     }
     else
     {
         nQtyOfLooks          <- 1
         nLookIndex           <- 1
         nQtyOfPatsInAnalysis <- nrow( SimData )
     }
     
     # Generate decision using GetDecisionString and GetDecision helpers
     strDecision <- CyneRgy::GetDecisionString( LookInfo, nLookIndex, nQtyOfLooks, 
                                                bIAEfficacyCondition = bIAEfficayCheck,
                                                bIAFutilityCondition = bIAFutilityCheck,
                                                bFAEfficacyCondition = bFAEfficacyCheck)
     nDecision <- CyneRgy::GetDecision( strDecision, DesignParam, LookInfo )
     
     
     return(list(Decision = as.integer(nDecision), PrimDelta = as.double(dPrimDeltaEst), SecDelta = as.double(dSecDeltaEst), ErrorCode = as.integer(nError)))
}
